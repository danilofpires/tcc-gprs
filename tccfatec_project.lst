CCS PCM C Compiler, Version 4.038, 56466               20-mai-10 19:37

               Filename: D:\TCC\tccfatec_gprs_serial\tccfatec_project.lst

               ROM used: 7261 words (89%)
                         Largest free fragment is 550
               RAM used: 257 (70%) at main() level
                         310 (84%) worst case
               Stack:    7 worst case (5 in main + 2 for interrupts)

*
0000:  MOVLW  18
0001:  MOVWF  0A
0002:  GOTO   41E
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  MOVLW  8C
001A:  MOVWF  04
001B:  BTFSS  00.5
001C:  GOTO   01F
001D:  BTFSC  0C.5
001E:  GOTO   038
001F:  MOVLW  8C
0020:  MOVWF  04
0021:  BTFSS  00.0
0022:  GOTO   025
0023:  BTFSC  0C.0
0024:  GOTO   03B
0025:  MOVF   22,W
0026:  MOVWF  04
0027:  MOVF   23,W
0028:  MOVWF  77
0029:  MOVF   24,W
002A:  MOVWF  78
002B:  MOVF   25,W
002C:  MOVWF  79
002D:  MOVF   26,W
002E:  MOVWF  7A
002F:  MOVF   27,W
0030:  MOVWF  7B
0031:  MOVF   20,W
0032:  MOVWF  0A
0033:  SWAPF  21,W
0034:  MOVWF  03
0035:  SWAPF  7F,F
0036:  SWAPF  7F,W
0037:  RETFIE
0038:  BCF    0A.3
0039:  BCF    0A.4
003A:  GOTO   352
003B:  BCF    0A.3
003C:  BCF    0A.4
003D:  GOTO   2D0
.................... //TCC Fatec SENAI GO 
.................... //Automação Industrial - Turma 05 
.................... //Danilo F. A. Pires / Jorge Wanderson Barbosa / Raphael de Paula Oliveira 
.................... //Subj: Sistema de comunicação por GPRS para controle remoto industrial através do envio de SMS por celulares. 
....................  
.................... #include "device.h"                 // chamada ao script do dispositivo 
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
....................  
.................... #device adc=10                   
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... //#FUSES BROWNOUT                 //Reset when brownout detected 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES WRT_50%                  //Lower half of Program Memory is Write Protected 
....................  
.................... #use delay(clock=8000000) 
*
0556:  MOVLW  91
0557:  MOVWF  04
0558:  BSF    03.7
0559:  MOVF   00,W
055A:  BTFSC  03.2
055B:  GOTO   569
055C:  MOVLW  02
055D:  MOVWF  78
055E:  CLRF   77
055F:  DECFSZ 77,F
0560:  GOTO   55F
0561:  DECFSZ 78,F
0562:  GOTO   55E
0563:  MOVLW  97
0564:  MOVWF  77
0565:  DECFSZ 77,F
0566:  GOTO   565
0567:  DECFSZ 00,F
0568:  GOTO   55C
0569:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
....................  
.................... #include <stdlib.h>                 // chamada de biblioteca stdlib 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
0507:  MOVF   2D,W
0508:  MOVWF  32
0509:  MOVF   2C,W
050A:  MOVWF  31
050B:  MOVF   30,F
050C:  BTFSC  03.2
050D:  GOTO   536
050E:  MOVF   2F,W
050F:  MOVWF  7A
0510:  MOVF   2E,W
0511:  MOVWF  04
0512:  BCF    03.7
0513:  BTFSC  7A.0
0514:  BSF    03.7
0515:  MOVF   00,F
0516:  BTFSC  03.2
0517:  GOTO   536
....................      *s++ = *s2++; 
0518:  MOVF   32,W
0519:  MOVWF  7A
051A:  MOVF   31,W
051B:  INCF   31,F
051C:  BTFSC  03.2
051D:  INCF   32,F
051E:  MOVWF  33
051F:  MOVF   7A,W
0520:  MOVWF  34
0521:  MOVF   2F,W
0522:  MOVWF  7A
0523:  MOVF   2E,W
0524:  INCF   2E,F
0525:  BTFSC  03.2
0526:  INCF   2F,F
0527:  MOVWF  04
0528:  BCF    03.7
0529:  BTFSC  7A.0
052A:  BSF    03.7
052B:  MOVF   00,W
052C:  MOVWF  35
052D:  MOVF   33,W
052E:  MOVWF  04
052F:  BCF    03.7
0530:  BTFSC  34.0
0531:  BSF    03.7
0532:  MOVF   35,W
0533:  MOVWF  00
0534:  DECF   30,F
0535:  GOTO   50B
....................   for (; n > 0; n--) 
0536:  MOVF   30,F
0537:  BTFSC  03.2
0538:  GOTO   546
....................      *s++ = '\0'; 
0539:  MOVF   32,W
053A:  MOVWF  7A
053B:  MOVF   31,W
053C:  INCF   31,F
053D:  BTFSC  03.2
053E:  INCF   32,F
053F:  MOVWF  04
0540:  BCF    03.7
0541:  BTFSC  7A.0
0542:  BSF    03.7
0543:  CLRF   00
0544:  DECF   30,F
0545:  GOTO   536
....................  
....................   return(s1); 
0546:  MOVF   2C,W
0547:  MOVWF  78
0548:  MOVF   2D,W
0549:  MOVWF  79
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0672:  BSF    03.6
0673:  MOVF   61,W
0674:  MOVWF  7A
0675:  MOVF   60,W
0676:  MOVWF  04
0677:  BCF    03.7
0678:  BTFSC  7A.0
0679:  BSF    03.7
067A:  MOVF   00,W
067B:  MOVWF  64
067C:  MOVF   63,W
067D:  MOVWF  7A
067E:  MOVF   62,W
067F:  MOVWF  04
0680:  BCF    03.7
0681:  BTFSC  7A.0
0682:  BSF    03.7
0683:  MOVF   00,W
0684:  SUBWF  64,W
0685:  BTFSS  03.2
0686:  GOTO   69E
....................       if (*s1 == '\0') 
0687:  MOVF   61,W
0688:  MOVWF  7A
0689:  MOVF   60,W
068A:  MOVWF  04
068B:  BCF    03.7
068C:  BTFSC  7A.0
068D:  BSF    03.7
068E:  MOVF   00,F
068F:  BTFSS  03.2
0690:  GOTO   694
....................          return(0); 
0691:  MOVLW  00
0692:  MOVWF  78
0693:  GOTO   6B7
0694:  MOVF   61,W
0695:  MOVWF  7A
0696:  MOVF   60,W
0697:  INCF   60,F
0698:  BTFSC  03.2
0699:  INCF   61,F
069A:  INCF   62,F
069B:  BTFSC  03.2
069C:  INCF   63,F
069D:  GOTO   673
....................    return((*s1 < *s2) ? -1: 1); 
069E:  MOVF   61,W
069F:  MOVWF  7A
06A0:  MOVF   60,W
06A1:  MOVWF  04
06A2:  BCF    03.7
06A3:  BTFSC  61.0
06A4:  BSF    03.7
06A5:  MOVF   00,W
06A6:  MOVWF  64
06A7:  MOVF   63,W
06A8:  MOVWF  7A
06A9:  MOVF   62,W
06AA:  MOVWF  04
06AB:  BCF    03.7
06AC:  BTFSC  63.0
06AD:  BSF    03.7
06AE:  MOVF   00,W
06AF:  SUBWF  64,W
06B0:  BTFSC  03.0
06B1:  GOTO   6B5
06B2:  MOVLW  FF
06B3:  MOVWF  7A
06B4:  GOTO   6B6
06B5:  MOVLW  01
06B6:  MOVWF  78
.................... } 
06B7:  BCF    03.6
06B8:  RETLW  00
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
02D8:  BSF    03.5
02D9:  BSF    03.6
02DA:  MOVF   2C,F
02DB:  BTFSC  03.2
02DC:  GOTO   327
....................       if (*s1 != *s2) 
02DD:  MOVF   29,W
02DE:  MOVWF  7A
02DF:  MOVF   28,W
02E0:  MOVWF  04
02E1:  BCF    03.7
02E2:  BTFSC  7A.0
02E3:  BSF    03.7
02E4:  MOVF   00,W
02E5:  MOVWF  2D
02E6:  MOVF   2B,W
02E7:  MOVWF  7A
02E8:  MOVF   2A,W
02E9:  MOVWF  04
02EA:  BCF    03.7
02EB:  BTFSC  7A.0
02EC:  BSF    03.7
02ED:  MOVF   00,W
02EE:  SUBWF  2D,W
02EF:  BTFSC  03.2
02F0:  GOTO   30C
....................          return((*s1 <*s2) ? -1: 1); 
02F1:  MOVF   29,W
02F2:  MOVWF  7A
02F3:  MOVF   28,W
02F4:  MOVWF  04
02F5:  BCF    03.7
02F6:  BTFSC  7A.0
02F7:  BSF    03.7
02F8:  MOVF   00,W
02F9:  MOVWF  2D
02FA:  MOVF   2B,W
02FB:  MOVWF  7A
02FC:  MOVF   2A,W
02FD:  MOVWF  04
02FE:  BCF    03.7
02FF:  BTFSC  7A.0
0300:  BSF    03.7
0301:  MOVF   00,W
0302:  SUBWF  2D,W
0303:  BTFSC  03.0
0304:  GOTO   308
0305:  MOVLW  FF
0306:  MOVWF  7A
0307:  GOTO   309
0308:  MOVLW  01
0309:  MOVWF  78
030A:  GOTO   329
....................       else if (*s1 == '\0') 
030B:  GOTO   319
030C:  MOVF   29,W
030D:  MOVWF  7A
030E:  MOVF   28,W
030F:  MOVWF  04
0310:  BCF    03.7
0311:  BTFSC  7A.0
0312:  BSF    03.7
0313:  MOVF   00,F
0314:  BTFSS  03.2
0315:  GOTO   319
....................          return(0); 
0316:  MOVLW  00
0317:  MOVWF  78
0318:  GOTO   329
0319:  MOVF   29,W
031A:  MOVWF  7A
031B:  MOVF   28,W
031C:  INCF   28,F
031D:  BTFSC  03.2
031E:  INCF   29,F
031F:  MOVF   2B,W
0320:  MOVWF  7A
0321:  MOVF   2A,W
0322:  INCF   2A,F
0323:  BTFSC  03.2
0324:  INCF   2B,F
0325:  DECF   2C,F
0326:  GOTO   2DA
....................    return(0); 
0327:  MOVLW  00
0328:  MOVWF  78
.................... } 
0329:  BCF    03.5
032A:  BCF    03.6
032B:  RETLW  00
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
032C:  BSF    03.5
032D:  BSF    03.6
032E:  MOVF   29,W
032F:  MOVWF  7A
0330:  MOVF   28,W
0331:  MOVWF  04
0332:  BCF    03.7
0333:  BTFSC  7A.0
0334:  BSF    03.7
0335:  MOVF   2A,W
0336:  SUBWF  00,W
0337:  BTFSC  03.2
0338:  GOTO   34B
....................       if (*s == '\0') 
0339:  MOVF   29,W
033A:  MOVWF  7A
033B:  MOVF   28,W
033C:  MOVWF  04
033D:  BCF    03.7
033E:  BTFSC  7A.0
033F:  BSF    03.7
0340:  MOVF   00,F
0341:  BTFSS  03.2
0342:  GOTO   347
....................          return(0); 
0343:  MOVLW  00
0344:  MOVWF  78
0345:  MOVWF  79
0346:  GOTO   34F
0347:  INCF   28,F
0348:  BTFSC  03.2
0349:  INCF   29,F
034A:  GOTO   32E
....................    return(s); 
034B:  MOVF   28,W
034C:  MOVWF  78
034D:  MOVF   29,W
034E:  MOVWF  79
.................... } 
034F:  BCF    03.5
0350:  BCF    03.6
0351:  RETLW  00
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1C31:  BCF    03.5
1C32:  CLRF   29
1C33:  CLRF   2A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
05A1:  MOVF   61,W
05A2:  MOVWF  63
05A3:  MOVF   60,W
05A4:  MOVWF  62
05A5:  MOVF   63,W
05A6:  MOVWF  7A
05A7:  MOVF   62,W
05A8:  MOVWF  04
05A9:  BCF    03.7
05AA:  BTFSC  7A.0
05AB:  BSF    03.7
05AC:  MOVF   00,F
05AD:  BTFSC  03.2
05AE:  GOTO   5B3
05AF:  INCF   62,F
05B0:  BTFSC  03.2
05B1:  INCF   63,F
05B2:  GOTO   5A5
....................    return(sc - s); 
05B3:  MOVF   60,W
05B4:  SUBWF  62,W
05B5:  MOVWF  77
05B6:  MOVF   63,W
05B7:  MOVWF  7A
05B8:  MOVF   61,W
05B9:  BTFSS  03.0
05BA:  INCFSZ 61,W
05BB:  SUBWF  7A,F
05BC:  MOVF   77,W
05BD:  MOVWF  78
05BE:  MOVF   7A,W
05BF:  MOVWF  79
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
*
0A18:  MOVLW  7F
0A19:  BSF    03.6
0A1A:  MOVWF  64
0A1B:  CLRF   65
0A1C:  CLRF   66
0A1D:  CLRF   67
....................    float result = 0.0; 
0A1E:  CLRF   68
0A1F:  CLRF   69
0A20:  CLRF   6A
0A21:  CLRF   6B
....................    int sign = 0; 
0A22:  CLRF   6C
....................    char c; 
....................    int ptr = 0; 
0A23:  CLRF   6E
....................  
....................    c = s[ptr++]; 
0A24:  MOVF   6E,W
0A25:  INCF   6E,F
0A26:  ADDWF  62,W
0A27:  MOVWF  04
0A28:  BCF    03.7
0A29:  BTFSC  63.0
0A2A:  BSF    03.7
0A2B:  MOVF   00,W
0A2C:  MOVWF  6D
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
0A2D:  MOVF   6D,W
0A2E:  SUBLW  2F
0A2F:  BTFSC  03.0
0A30:  GOTO   235
0A31:  MOVF   6D,W
0A32:  SUBLW  39
0A33:  BTFSC  03.0
0A34:  GOTO   241
0A35:  MOVF   6D,W
0A36:  SUBLW  2B
0A37:  BTFSC  03.2
0A38:  GOTO   241
0A39:  MOVF   6D,W
0A3A:  SUBLW  2D
0A3B:  BTFSC  03.2
0A3C:  GOTO   241
0A3D:  MOVF   6D,W
0A3E:  SUBLW  2E
0A3F:  BTFSS  03.2
0A40:  GOTO   368
....................       if(c == '-') { 
0A41:  MOVF   6D,W
0A42:  SUBLW  2D
0A43:  BTFSS  03.2
0A44:  GOTO   250
....................          sign = 1; 
0A45:  MOVLW  01
0A46:  MOVWF  6C
....................          c = s[ptr++]; 
0A47:  MOVF   6E,W
0A48:  INCF   6E,F
0A49:  ADDWF  62,W
0A4A:  MOVWF  04
0A4B:  BCF    03.7
0A4C:  BTFSC  63.0
0A4D:  BSF    03.7
0A4E:  MOVF   00,W
0A4F:  MOVWF  6D
....................       } 
....................       if(c == '+') 
0A50:  MOVF   6D,W
0A51:  SUBLW  2B
0A52:  BTFSS  03.2
0A53:  GOTO   25D
....................          c = s[ptr++]; 
0A54:  MOVF   6E,W
0A55:  INCF   6E,F
0A56:  ADDWF  62,W
0A57:  MOVWF  04
0A58:  BCF    03.7
0A59:  BTFSC  63.0
0A5A:  BSF    03.7
0A5B:  MOVF   00,W
0A5C:  MOVWF  6D
....................  
....................       while((c >= '0' && c <= '9')) { 
0A5D:  MOVF   6D,W
0A5E:  SUBLW  2F
0A5F:  BTFSC  03.0
0A60:  GOTO   2DA
0A61:  MOVF   6D,W
0A62:  SUBLW  39
0A63:  BTFSS  03.0
0A64:  GOTO   2DA
....................          result = 10*result + c - '0'; 
0A65:  BSF    03.5
0A66:  CLRF   13
0A67:  CLRF   12
0A68:  MOVLW  20
0A69:  MOVWF  11
0A6A:  MOVLW  82
0A6B:  MOVWF  10
0A6C:  BCF    03.5
0A6D:  MOVF   6B,W
0A6E:  BSF    03.5
0A6F:  MOVWF  17
0A70:  BCF    03.5
0A71:  MOVF   6A,W
0A72:  BSF    03.5
0A73:  MOVWF  16
0A74:  BCF    03.5
0A75:  MOVF   69,W
0A76:  BSF    03.5
0A77:  MOVWF  15
0A78:  BCF    03.5
0A79:  MOVF   68,W
0A7A:  BSF    03.5
0A7B:  MOVWF  14
0A7C:  BCF    0A.3
0A7D:  BCF    03.5
0A7E:  BCF    03.6
0A7F:  CALL   6B9
0A80:  BSF    0A.3
0A81:  MOVF   77,W
0A82:  BSF    03.5
0A83:  BSF    03.6
0A84:  MOVWF  10
0A85:  MOVF   78,W
0A86:  MOVWF  11
0A87:  MOVF   79,W
0A88:  MOVWF  12
0A89:  MOVF   7A,W
0A8A:  MOVWF  13
0A8B:  CLRF   15
0A8C:  BCF    03.5
0A8D:  MOVF   6D,W
0A8E:  BSF    03.5
0A8F:  MOVWF  14
0A90:  BCF    0A.3
0A91:  BCF    03.5
0A92:  BCF    03.6
0A93:  CALL   732
0A94:  BSF    0A.3
0A95:  BCF    03.1
0A96:  BSF    03.5
0A97:  BSF    03.6
0A98:  MOVF   13,W
0A99:  MOVWF  1B
0A9A:  MOVF   12,W
0A9B:  MOVWF  1A
0A9C:  MOVF   11,W
0A9D:  MOVWF  19
0A9E:  MOVF   10,W
0A9F:  MOVWF  18
0AA0:  MOVF   7A,W
0AA1:  MOVWF  1F
0AA2:  MOVF   79,W
0AA3:  MOVWF  1E
0AA4:  MOVF   78,W
0AA5:  MOVWF  1D
0AA6:  MOVF   77,W
0AA7:  MOVWF  1C
0AA8:  BCF    03.5
0AA9:  BCF    03.6
0AAA:  CALL   000
0AAB:  MOVF   77,W
0AAC:  BSF    03.5
0AAD:  BSF    03.6
0AAE:  MOVWF  14
0AAF:  MOVF   78,W
0AB0:  MOVWF  15
0AB1:  MOVF   79,W
0AB2:  MOVWF  16
0AB3:  MOVF   7A,W
0AB4:  MOVWF  17
0AB5:  BSF    03.1
0AB6:  MOVF   17,W
0AB7:  MOVWF  1B
0AB8:  MOVF   16,W
0AB9:  MOVWF  1A
0ABA:  MOVF   15,W
0ABB:  MOVWF  19
0ABC:  MOVF   14,W
0ABD:  MOVWF  18
0ABE:  CLRF   1F
0ABF:  CLRF   1E
0AC0:  MOVLW  40
0AC1:  MOVWF  1D
0AC2:  MOVLW  84
0AC3:  MOVWF  1C
0AC4:  BCF    03.5
0AC5:  BCF    03.6
0AC6:  CALL   000
0AC7:  MOVF   7A,W
0AC8:  BSF    03.6
0AC9:  MOVWF  6B
0ACA:  MOVF   79,W
0ACB:  MOVWF  6A
0ACC:  MOVF   78,W
0ACD:  MOVWF  69
0ACE:  MOVF   77,W
0ACF:  MOVWF  68
....................          c = s[ptr++]; 
0AD0:  MOVF   6E,W
0AD1:  INCF   6E,F
0AD2:  ADDWF  62,W
0AD3:  MOVWF  04
0AD4:  BCF    03.7
0AD5:  BTFSC  63.0
0AD6:  BSF    03.7
0AD7:  MOVF   00,W
0AD8:  MOVWF  6D
....................       } 
0AD9:  GOTO   25D
....................  
....................       if (c == '.') { 
0ADA:  MOVF   6D,W
0ADB:  SUBLW  2E
0ADC:  BTFSS  03.2
0ADD:  GOTO   368
....................          c = s[ptr++]; 
0ADE:  MOVF   6E,W
0ADF:  INCF   6E,F
0AE0:  ADDWF  62,W
0AE1:  MOVWF  04
0AE2:  BCF    03.7
0AE3:  BTFSC  63.0
0AE4:  BSF    03.7
0AE5:  MOVF   00,W
0AE6:  MOVWF  6D
....................          while((c >= '0' && c <= '9')) { 
0AE7:  MOVF   6D,W
0AE8:  SUBLW  2F
0AE9:  BTFSC  03.0
0AEA:  GOTO   368
0AEB:  MOVF   6D,W
0AEC:  SUBLW  39
0AED:  BTFSS  03.0
0AEE:  GOTO   368
....................              pow10 = pow10*10; 
0AEF:  MOVF   67,W
0AF0:  BSF    03.5
0AF1:  MOVWF  13
0AF2:  BCF    03.5
0AF3:  MOVF   66,W
0AF4:  BSF    03.5
0AF5:  MOVWF  12
0AF6:  BCF    03.5
0AF7:  MOVF   65,W
0AF8:  BSF    03.5
0AF9:  MOVWF  11
0AFA:  BCF    03.5
0AFB:  MOVF   64,W
0AFC:  BSF    03.5
0AFD:  MOVWF  10
0AFE:  CLRF   17
0AFF:  CLRF   16
0B00:  MOVLW  20
0B01:  MOVWF  15
0B02:  MOVLW  82
0B03:  MOVWF  14
0B04:  BCF    0A.3
0B05:  BCF    03.5
0B06:  BCF    03.6
0B07:  CALL   6B9
0B08:  BSF    0A.3
0B09:  MOVF   7A,W
0B0A:  BSF    03.6
0B0B:  MOVWF  67
0B0C:  MOVF   79,W
0B0D:  MOVWF  66
0B0E:  MOVF   78,W
0B0F:  MOVWF  65
0B10:  MOVF   77,W
0B11:  MOVWF  64
....................              result += (c - '0')/pow10; 
0B12:  MOVLW  30
0B13:  SUBWF  6D,W
0B14:  BSF    03.5
0B15:  CLRF   15
0B16:  MOVWF  14
0B17:  BCF    0A.3
0B18:  BCF    03.5
0B19:  BCF    03.6
0B1A:  CALL   732
0B1B:  BSF    0A.3
0B1C:  MOVF   7A,W
0B1D:  BSF    03.5
0B1E:  BSF    03.6
0B1F:  MOVWF  14
0B20:  MOVF   79,W
0B21:  MOVWF  13
0B22:  MOVF   78,W
0B23:  MOVWF  12
0B24:  MOVF   77,W
0B25:  MOVWF  11
0B26:  BCF    03.5
0B27:  MOVF   67,W
0B28:  BSF    03.5
0B29:  MOVWF  18
0B2A:  BCF    03.5
0B2B:  MOVF   66,W
0B2C:  BSF    03.5
0B2D:  MOVWF  17
0B2E:  BCF    03.5
0B2F:  MOVF   65,W
0B30:  BSF    03.5
0B31:  MOVWF  16
0B32:  BCF    03.5
0B33:  MOVF   64,W
0B34:  BSF    03.5
0B35:  MOVWF  15
0B36:  BCF    03.5
0B37:  BCF    03.6
0B38:  CALL   14A
0B39:  BCF    03.1
0B3A:  BSF    03.6
0B3B:  MOVF   6B,W
0B3C:  BSF    03.5
0B3D:  MOVWF  1B
0B3E:  BCF    03.5
0B3F:  MOVF   6A,W
0B40:  BSF    03.5
0B41:  MOVWF  1A
0B42:  BCF    03.5
0B43:  MOVF   69,W
0B44:  BSF    03.5
0B45:  MOVWF  19
0B46:  BCF    03.5
0B47:  MOVF   68,W
0B48:  BSF    03.5
0B49:  MOVWF  18
0B4A:  MOVF   7A,W
0B4B:  MOVWF  1F
0B4C:  MOVF   79,W
0B4D:  MOVWF  1E
0B4E:  MOVF   78,W
0B4F:  MOVWF  1D
0B50:  MOVF   77,W
0B51:  MOVWF  1C
0B52:  BCF    03.5
0B53:  BCF    03.6
0B54:  CALL   000
0B55:  MOVF   7A,W
0B56:  BSF    03.6
0B57:  MOVWF  6B
0B58:  MOVF   79,W
0B59:  MOVWF  6A
0B5A:  MOVF   78,W
0B5B:  MOVWF  69
0B5C:  MOVF   77,W
0B5D:  MOVWF  68
....................              c = s[ptr++]; 
0B5E:  MOVF   6E,W
0B5F:  INCF   6E,F
0B60:  ADDWF  62,W
0B61:  MOVWF  04
0B62:  BCF    03.7
0B63:  BTFSC  63.0
0B64:  BSF    03.7
0B65:  MOVF   00,W
0B66:  MOVWF  6D
....................          } 
0B67:  GOTO   2E7
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
0B68:  DECFSZ 6C,W
0B69:  GOTO   38F
....................       result = -1*result; 
0B6A:  BSF    03.5
0B6B:  CLRF   13
0B6C:  CLRF   12
0B6D:  MOVLW  80
0B6E:  MOVWF  11
0B6F:  MOVLW  7F
0B70:  MOVWF  10
0B71:  BCF    03.5
0B72:  MOVF   6B,W
0B73:  BSF    03.5
0B74:  MOVWF  17
0B75:  BCF    03.5
0B76:  MOVF   6A,W
0B77:  BSF    03.5
0B78:  MOVWF  16
0B79:  BCF    03.5
0B7A:  MOVF   69,W
0B7B:  BSF    03.5
0B7C:  MOVWF  15
0B7D:  BCF    03.5
0B7E:  MOVF   68,W
0B7F:  BSF    03.5
0B80:  MOVWF  14
0B81:  BCF    0A.3
0B82:  BCF    03.5
0B83:  BCF    03.6
0B84:  CALL   6B9
0B85:  BSF    0A.3
0B86:  MOVF   7A,W
0B87:  BSF    03.6
0B88:  MOVWF  6B
0B89:  MOVF   79,W
0B8A:  MOVWF  6A
0B8B:  MOVF   78,W
0B8C:  MOVWF  69
0B8D:  MOVF   77,W
0B8E:  MOVWF  68
....................    return(result); 
0B8F:  MOVF   68,W
0B90:  MOVWF  77
0B91:  MOVF   69,W
0B92:  MOVWF  78
0B93:  MOVF   6A,W
0B94:  MOVWF  79
0B95:  MOVF   6B,W
0B96:  MOVWF  7A
.................... } 
0B97:  BCF    03.6
0B98:  RETLW  00
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
03CD:  CLRF   31
....................    sign = 0; 
03CE:  CLRF   2F
....................    base = 10; 
03CF:  MOVLW  0A
03D0:  MOVWF  30
....................    result = 0; 
03D1:  CLRF   2E
....................  
....................    if (!s) 
03D2:  MOVF   2C,W
03D3:  IORWF  2D,W
03D4:  BTFSS  03.2
03D5:  GOTO   3D9
....................       return 0; 
03D6:  MOVLW  00
03D7:  MOVWF  78
03D8:  GOTO   4CC
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
03D9:  MOVF   31,W
03DA:  INCF   31,F
03DB:  ADDWF  2C,W
03DC:  MOVWF  04
03DD:  BCF    03.7
03DE:  BTFSC  2D.0
03DF:  BSF    03.7
03E0:  MOVF   00,W
03E1:  MOVWF  32
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
03E2:  MOVF   32,W
03E3:  SUBLW  2D
03E4:  BTFSS  03.2
03E5:  GOTO   3F2
....................    { 
....................       sign = 1;         // Set the sign to negative 
03E6:  MOVLW  01
03E7:  MOVWF  2F
....................       c = s[index++]; 
03E8:  MOVF   31,W
03E9:  INCF   31,F
03EA:  ADDWF  2C,W
03EB:  MOVWF  04
03EC:  BCF    03.7
03ED:  BTFSC  2D.0
03EE:  BSF    03.7
03EF:  MOVF   00,W
03F0:  MOVWF  32
....................    } 
....................    else if (c == '+') 
03F1:  GOTO   3FF
03F2:  MOVF   32,W
03F3:  SUBLW  2B
03F4:  BTFSS  03.2
03F5:  GOTO   3FF
....................    { 
....................       c = s[index++]; 
03F6:  MOVF   31,W
03F7:  INCF   31,F
03F8:  ADDWF  2C,W
03F9:  MOVWF  04
03FA:  BCF    03.7
03FB:  BTFSC  2D.0
03FC:  BSF    03.7
03FD:  MOVF   00,W
03FE:  MOVWF  32
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
03FF:  MOVF   32,W
0400:  SUBLW  2F
0401:  BTFSC  03.0
0402:  GOTO   4C2
0403:  MOVF   32,W
0404:  SUBLW  39
0405:  BTFSS  03.0
0406:  GOTO   4C2
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0407:  MOVF   32,W
0408:  SUBLW  30
0409:  BTFSS  03.2
040A:  GOTO   42B
040B:  MOVF   31,W
040C:  ADDWF  2C,W
040D:  MOVWF  04
040E:  BCF    03.7
040F:  BTFSC  2D.0
0410:  BSF    03.7
0411:  MOVF   00,W
0412:  SUBLW  78
0413:  BTFSC  03.2
0414:  GOTO   41F
0415:  MOVF   31,W
0416:  ADDWF  2C,W
0417:  MOVWF  04
0418:  BCF    03.7
0419:  BTFSC  2D.0
041A:  BSF    03.7
041B:  MOVF   00,W
041C:  SUBLW  58
041D:  BTFSS  03.2
041E:  GOTO   42B
....................       { 
....................          base = 16; 
041F:  MOVLW  10
0420:  MOVWF  30
....................          index++; 
0421:  INCF   31,F
....................          c = s[index++]; 
0422:  MOVF   31,W
0423:  INCF   31,F
0424:  ADDWF  2C,W
0425:  MOVWF  04
0426:  BCF    03.7
0427:  BTFSC  2D.0
0428:  BSF    03.7
0429:  MOVF   00,W
042A:  MOVWF  32
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
042B:  MOVF   30,W
042C:  SUBLW  0A
042D:  BTFSS  03.2
042E:  GOTO   470
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
042F:  MOVF   32,W
0430:  SUBLW  2F
0431:  BTFSC  03.0
0432:  GOTO   46F
0433:  MOVF   32,W
0434:  SUBLW  39
0435:  BTFSS  03.0
0436:  GOTO   46F
....................             result = 10*result + (c - '0'); 
0437:  MOVLW  0A
0438:  MOVWF  33
0439:  MOVF   2E,W
043A:  MOVWF  34
*
045F:  MOVF   78,W
0460:  MOVWF  33
0461:  MOVLW  30
0462:  SUBWF  32,W
0463:  ADDWF  33,W
0464:  MOVWF  2E
....................             c = s[index++]; 
0465:  MOVF   31,W
0466:  INCF   31,F
0467:  ADDWF  2C,W
0468:  MOVWF  04
0469:  BCF    03.7
046A:  BTFSC  2D.0
046B:  BSF    03.7
046C:  MOVF   00,W
046D:  MOVWF  32
....................          } 
046E:  GOTO   42F
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
046F:  GOTO   4C2
0470:  MOVF   30,W
0471:  SUBLW  10
0472:  BTFSS  03.2
0473:  GOTO   4C2
....................       { 
....................          c = toupper(c); 
0474:  MOVF   32,W
0475:  SUBLW  60
0476:  BTFSC  03.0
0477:  GOTO   47F
0478:  MOVF   32,W
0479:  SUBLW  7A
047A:  BTFSS  03.0
047B:  GOTO   47F
047C:  MOVF   32,W
047D:  ANDLW  DF
047E:  GOTO   480
047F:  MOVF   32,W
0480:  MOVWF  32
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
0481:  MOVF   32,W
0482:  SUBLW  2F
0483:  BTFSC  03.0
0484:  GOTO   489
0485:  MOVF   32,W
0486:  SUBLW  39
0487:  BTFSC  03.0
0488:  GOTO   491
0489:  MOVF   32,W
048A:  SUBLW  40
048B:  BTFSC  03.0
048C:  GOTO   4C2
048D:  MOVF   32,W
048E:  SUBLW  46
048F:  BTFSS  03.0
0490:  GOTO   4C2
....................             if (c >= '0' && c <= '9') 
0491:  MOVF   32,W
0492:  SUBLW  2F
0493:  BTFSC  03.0
0494:  GOTO   4A2
0495:  MOVF   32,W
0496:  SUBLW  39
0497:  BTFSS  03.0
0498:  GOTO   4A2
....................                result = (result << 4) + (c - '0'); 
0499:  SWAPF  2E,W
049A:  MOVWF  33
049B:  MOVLW  F0
049C:  ANDWF  33,F
049D:  MOVLW  30
049E:  SUBWF  32,W
049F:  ADDWF  33,W
04A0:  MOVWF  2E
....................             else 
04A1:  GOTO   4AB
....................                result = (result << 4) + (c - 'A' + 10); 
04A2:  SWAPF  2E,W
04A3:  MOVWF  33
04A4:  MOVLW  F0
04A5:  ANDWF  33,F
04A6:  MOVLW  41
04A7:  SUBWF  32,W
04A8:  ADDLW  0A
04A9:  ADDWF  33,W
04AA:  MOVWF  2E
....................  
....................             c = s[index++]; 
04AB:  MOVF   31,W
04AC:  INCF   31,F
04AD:  ADDWF  2C,W
04AE:  MOVWF  04
04AF:  BCF    03.7
04B0:  BTFSC  2D.0
04B1:  BSF    03.7
04B2:  MOVF   00,W
04B3:  MOVWF  32
....................             c = toupper(c); 
04B4:  MOVF   32,W
04B5:  SUBLW  60
04B6:  BTFSC  03.0
04B7:  GOTO   4BF
04B8:  MOVF   32,W
04B9:  SUBLW  7A
04BA:  BTFSS  03.0
04BB:  GOTO   4BF
04BC:  MOVF   32,W
04BD:  ANDLW  DF
04BE:  GOTO   4C0
04BF:  MOVF   32,W
04C0:  MOVWF  32
....................          } 
04C1:  GOTO   481
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
04C2:  DECFSZ 2F,W
04C3:  GOTO   4CA
04C4:  MOVF   30,W
04C5:  SUBLW  0A
04C6:  BTFSS  03.2
04C7:  GOTO   4CA
....................        result = -result; 
04C8:  COMF   2E,F
04C9:  INCF   2E,F
....................  
....................    return(result); 
04CA:  MOVF   2E,W
04CB:  MOVWF  78
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h>                   // chamada de biblioteca de operacoes matematicas 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.141592654 
....................  
....................  
.................... #define SQRT2  1.41421356 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float CEIL_FLOOR(float x, int n) 
.................... { 
....................    float y, res; 
....................    long l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float)(long)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (long)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float)l); 
....................   res = 32768.0*(float)l; 
....................   res += (float)(long)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float)(long)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float floor(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float ceil(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float x,float y) 
.................... { 
....................    float i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
....................  
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
....................  
.................... #define LN2 0.6931471806 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... float exp(float x) 
.................... { 
....................    float y, res, r; 
....................    signed int n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed long)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................    *((int8 *)(&res)) = n + 0x7F; 
....................  
....................    y = y/LN2 - (float)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... /************************************************************/ 
....................  
.................... float const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float log(float x) 
.................... { 
....................    float y, res, r, y2; 
....................  
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................      *((int8 *)(&y)) = 0x7E;  
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................       n = *((int8 *)(&x)) - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float)-n; 
....................       else 
....................          r = (float)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... #define LN10 2.30258509 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float log10(float x) 
.................... { 
....................    float r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float modf(float value,float *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pwr(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pow(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float sqrt(float x) 
.................... { 
....................    float y, res; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p=&y; 
....................    (*p)=(BYTE)((((int16)(*p)) + 127) >> 1); 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................       (*p)--; 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
....................  
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.570796326794896 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197724 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float cos(float x) 
.................... { 
....................    float y, t, t2 = 1.0; 
....................    int quad, i; 
....................    float frac; 
....................    float p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (int)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float sin(float x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float tan(float x) 
.................... { 
....................    float c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
....................  
....................  
.................... float const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float ASIN_COS(float x, int n) 
.................... { 
....................    float y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float asin(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float acos(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... float const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float atan(float x) 
.................... { 
....................    float y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
....................  
.................... float atan2(float y,float x) 
.................... { 
....................    float z; 
....................    int1 sign; 
....................    int quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float cosh(float x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float sinh(float x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float tanh(float x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
....................  
....................  
.................... #define LOG2 .30102999566398119521 
.................... float frexp(float x, signed int *exp) 
.................... { 
....................    float res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float ldexp(float value, signed int exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #include "lcd.h"                    // chamada a biblioteca de LCD 
.................... // lcd.h 
....................  
.................... // Endereços das linhas do LCD 
.................... // linha01 = end=0x80; 
.................... // linha02 = end=0xC0; 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #byte portd=0x08 
.................... #byte porte=0x09 
.................... #bit  rs = porte.2 
.................... #bit  enable = porte.1 
....................  
.................... int   x=0; 
*
1C34:  CLRF   2F
.................... int   tam; 
.................... char  msg[80]; 
....................  
.................... void comando_lcd(int caractere){ 
....................    rs=0; 
*
056A:  BCF    09.2
....................    enable=1; 
056B:  BSF    09.1
....................    portd=caractere; 
056C:  BSF    03.6
056D:  MOVF   62,W
056E:  BCF    03.6
056F:  MOVWF  08
....................    delay_ms(3); 
0570:  MOVLW  03
0571:  BSF    03.5
0572:  BSF    03.6
0573:  MOVWF  11
0574:  BCF    03.5
0575:  BCF    03.6
0576:  CALL   556
....................    enable=0; 
0577:  BCF    09.1
.................... } 
0578:  RETLW  00
....................  
.................... void escreve_lcd(int caractere){ 
....................    rs=1; 
*
058C:  BSF    09.2
....................    enable=1; 
058D:  BSF    09.1
....................    portd=caractere; 
058E:  BSF    03.5
058F:  BSF    03.6
0590:  MOVF   10,W
0591:  BCF    03.5
0592:  BCF    03.6
0593:  MOVWF  08
....................    delay_ms(3); 
0594:  MOVLW  03
0595:  BSF    03.5
0596:  BSF    03.6
0597:  MOVWF  11
0598:  BCF    03.5
0599:  BCF    03.6
059A:  CALL   556
....................    enable=0; 
059B:  BCF    09.1
.................... } 
059C:  RETLW  00
....................  
.................... void inicializa_lcd(){ 
....................    comando_lcd(0b00111100); 
*
0579:  MOVLW  3C
057A:  BSF    03.6
057B:  MOVWF  62
057C:  BCF    03.6
057D:  CALL   56A
....................    comando_lcd(0b00001100); 
057E:  MOVLW  0C
057F:  BSF    03.6
0580:  MOVWF  62
0581:  BCF    03.6
0582:  CALL   56A
.................... } 
0583:  BSF    0A.3
0584:  BSF    0A.4
0585:  GOTO   52A (RETURN)
....................  
.................... void limpa_lcd(){ 
....................    comando_lcd(0b00000001); 
0586:  MOVLW  01
0587:  BSF    03.6
0588:  MOVWF  62
0589:  BCF    03.6
058A:  CALL   56A
.................... } 
058B:  RETLW  00
....................  
.................... void limpa_lcd_linha(){ 
....................    printf(escreve_lcd,"                  "); 
.................... } 
....................  
.................... void limpa_msg(void){ 
....................    tam=strlen(msg); 
*
059D:  BSF    03.6
059E:  CLRF   61
059F:  MOVLW  A0
05A0:  MOVWF  60
*
05C0:  MOVF   78,W
05C1:  BCF    03.6
05C2:  MOVWF  30
....................    for(x=0;x<tam;x=x+1) 
05C3:  CLRF   2F
05C4:  MOVF   30,W
05C5:  SUBWF  2F,W
05C6:  BTFSC  03.0
05C7:  GOTO   5E2
....................    { 
....................       msg[x]=0; 
05C8:  MOVLW  A0
05C9:  ADDWF  2F,W
05CA:  MOVWF  04
05CB:  BCF    03.7
05CC:  CLRF   00
....................       printf("%c",msg[x]); 
05CD:  MOVLW  A0
05CE:  ADDWF  2F,W
05CF:  MOVWF  04
05D0:  BCF    03.7
05D1:  MOVF   00,W
05D2:  BSF    03.6
05D3:  MOVWF  60
05D4:  BCF    03.6
05D5:  BTFSS  0C.4
05D6:  GOTO   5D5
05D7:  MOVWF  19
....................       delay_ms(100); 
05D8:  MOVLW  64
05D9:  BSF    03.5
05DA:  BSF    03.6
05DB:  MOVWF  11
05DC:  BCF    03.5
05DD:  BCF    03.6
05DE:  CALL   556
....................    } 
05DF:  MOVLW  01
05E0:  ADDWF  2F,F
05E1:  GOTO   5C4
....................    x=0; 
05E2:  CLRF   2F
.................... } 
05E3:  BSF    0A.3
05E4:  BSF    0A.4
05E5:  GOTO   5A8 (RETURN)
....................  
....................  
.................... #include "script_variaveis.h"       // script com as variaveis do sistema 
.................... // variaveis.h 
....................  
....................  
.................... // Modo de Operação do Firmware / modo protótipo 0 (default) / Kit de testes modo 1 
.................... int   firmwaremode=0; 
*
1C35:  CLRF   31
....................  
.................... // Gerais 
.................... #locate  rc_reg=0x1A 
....................  
.................... #byte porta=0x05 
.................... #byte portb=0x06 
.................... #byte portc=0x07 
.................... #byte txsta=0x98 
.................... #byte rcsta=0x18 
....................  
.................... #bit  bt1=portb.0 
.................... #bit  bt2=portb.1 
.................... #bit  bt3=portb.2 
.................... #bit  bt4=portb.3 
.................... #bit  bt5=portb.4 
.................... #bit  ledalerta=portb.5 
.................... #bit  ledmerg=portb.6 
.................... #bit  ledcooler=portb.7 
....................  
.................... #bit  ledrele=portc.0 
.................... #bit  buzzer=portc.1 
.................... #bit  cooler=portc.2 
.................... #bit  ledon=portc.3 
.................... #bit  rele=portc.4 
.................... #bit  merg=portc.5 
....................  
....................  
.................... // Variaveis e Constantes 
.................... unsigned int contTimeOut=0; 
1C36:  CLRF   32
.................... char  chegou;                    // variavel que recebe todos os valores que chegam da serial 
.................... int   cont=0;                    // int responsavel por contagem de caracteres recebidos 
1C37:  CLRF   34
.................... char  fim;                       // caracter que passa final de mensagem SMS   
.................... int   tipoComando=0;             // Tipo de comando recebido (CMGR, CMTI, OK ou outro configurado) 
1C38:  CLRF   36
.................... char  sms[16];                   // Variavel que contem a mensagem SMS recebida do modem 
.................... int   contSMS=0;                 // Contador de caracteres da SMS 
1C39:  CLRF   47
.................... char  ok[]={"OK"};               // Variavel que determina o conteúdo de uma mensagem tipo OK 
1C3A:  MOVLW  4F
1C3B:  MOVWF  48
1C3C:  MOVLW  4B
1C3D:  MOVWF  49
1C3E:  CLRF   4A
.................... char  cmti[]={"+CMTI"};          // Variavel que determina o conteúdo de uma mensagem tipo CMTI 
1C3F:  MOVLW  2B
1C40:  MOVWF  4B
1C41:  MOVLW  43
1C42:  MOVWF  4C
1C43:  MOVLW  4D
1C44:  MOVWF  4D
1C45:  MOVLW  54
1C46:  MOVWF  4E
1C47:  MOVLW  49
1C48:  MOVWF  4F
1C49:  CLRF   50
.................... char  cmgr[]={"+CMGR"};          // Variavel que determina o conteúdo de uma mensagem tipo CMGR 
1C4A:  MOVLW  2B
1C4B:  MOVWF  51
1C4C:  MOVLW  43
1C4D:  MOVWF  52
1C4E:  MOVLW  4D
1C4F:  MOVWF  53
1C50:  MOVLW  47
1C51:  MOVWF  54
1C52:  MOVLW  52
1C53:  MOVWF  55
1C54:  CLRF   56
.................... int   cmtiIndex=0; 
1C55:  CLRF   57
.................... char  flagSMS=FALSE;             // Flag responsável pela detecção da mensagem SMS. 
1C56:  CLRF   58
.................... int   flagPlantaLigada=FALSE;    // Flag que armazena condicao da planta 
1C57:  CLRF   59
....................  
....................  
.................... float tensao; 
.................... float setpoint=0;                // Setpoint de trabalho da planta 
1C58:  CLRF   5E
1C59:  CLRF   5F
1C5A:  CLRF   60
1C5B:  CLRF   61
.................... float setpointgap=0.5;           // Intervalo de incremento e decremento do Setpoint 
1C5C:  MOVLW  7E
1C5D:  MOVWF  62
1C5E:  CLRF   63
1C5F:  CLRF   64
1C60:  CLRF   65
.................... float temp=0;                    // Temperatura real da planta 
1C61:  CLRF   66
1C62:  CLRF   67
1C63:  CLRF   68
1C64:  CLRF   69
.................... float tempinicial=25;            // Temperatura padrao para inicio de atividades da planta 
1C65:  MOVLW  83
1C66:  MOVWF  6A
1C67:  MOVLW  48
1C68:  MOVWF  6B
1C69:  CLRF   6C
1C6A:  CLRF   6D
.................... char  fone[]={"6296899991"};     // Numero inicial de telefone celular que envia comando 
1C6B:  MOVLW  36
1C6C:  BSF    03.6
1C6D:  MOVWF  10
1C6E:  MOVLW  32
1C6F:  MOVWF  11
1C70:  MOVLW  39
1C71:  MOVWF  12
1C72:  MOVLW  36
1C73:  MOVWF  13
1C74:  MOVLW  38
1C75:  MOVWF  14
1C76:  MOVLW  39
1C77:  MOVWF  15
1C78:  MOVWF  16
1C79:  MOVWF  17
1C7A:  MOVWF  18
1C7B:  MOVLW  31
1C7C:  MOVWF  19
1C7D:  CLRF   1A
.................... float tempgap=5;                 // Intervalo entre Temp Superior e Temp Inferior  
1C7E:  MOVLW  81
1C7F:  BCF    03.6
1C80:  MOVWF  6E
1C81:  MOVLW  20
1C82:  MOVWF  6F
1C83:  CLRF   70
1C84:  CLRF   71
.................... float tempalerta=39.5;           // Valor a ser somado a tempgap que acarretará o alerta 
1C85:  MOVLW  84
1C86:  MOVWF  72
1C87:  MOVLW  1E
1C88:  MOVWF  73
1C89:  CLRF   74
1C8A:  CLRF   75
.................... int   conttemp=0;                // Contador de avaliações de temperatura para média de leituras 
1C8B:  CLRF   76
.................... int   statusrele=0;              // estado do Rele 
1C8C:  CLRF   7C
....................  
.................... // SMS 
.................... char  smsplantaon[]={"plantaon"}; 
1C8D:  MOVLW  70
1C8E:  BSF    03.6
1C8F:  MOVWF  1B
1C90:  MOVLW  6C
1C91:  MOVWF  1C
1C92:  MOVLW  61
1C93:  MOVWF  1D
1C94:  MOVLW  6E
1C95:  MOVWF  1E
1C96:  MOVLW  74
1C97:  MOVWF  1F
1C98:  MOVLW  61
1C99:  MOVWF  20
1C9A:  MOVLW  6F
1C9B:  MOVWF  21
1C9C:  MOVLW  6E
1C9D:  MOVWF  22
1C9E:  CLRF   23
.................... char  smsplantasp[]={"ponstp: "}; 
1C9F:  MOVLW  70
1CA0:  MOVWF  24
1CA1:  MOVLW  6F
1CA2:  MOVWF  25
1CA3:  MOVLW  6E
1CA4:  MOVWF  26
1CA5:  MOVLW  73
1CA6:  MOVWF  27
1CA7:  MOVLW  74
1CA8:  MOVWF  28
1CA9:  MOVLW  70
1CAA:  MOVWF  29
1CAB:  MOVLW  3A
1CAC:  MOVWF  2A
1CAD:  MOVLW  20
1CAE:  MOVWF  2B
1CAF:  CLRF   2C
.................... char  smsplantaoff[]={"plantaoff"}; 
1CB0:  MOVLW  70
1CB1:  MOVWF  2D
1CB2:  MOVLW  6C
1CB3:  MOVWF  2E
1CB4:  MOVLW  61
1CB5:  MOVWF  2F
1CB6:  MOVLW  6E
1CB7:  MOVWF  30
1CB8:  MOVLW  74
1CB9:  MOVWF  31
1CBA:  MOVLW  61
1CBB:  MOVWF  32
1CBC:  MOVLW  6F
1CBD:  MOVWF  33
1CBE:  MOVLW  66
1CBF:  MOVWF  34
1CC0:  MOVWF  35
1CC1:  CLRF   36
.................... char  smstemp[]={"temprec"}; 
1CC2:  MOVLW  74
1CC3:  MOVWF  37
1CC4:  MOVLW  65
1CC5:  MOVWF  38
1CC6:  MOVLW  6D
1CC7:  MOVWF  39
1CC8:  MOVLW  70
1CC9:  MOVWF  3A
1CCA:  MOVLW  72
1CCB:  MOVWF  3B
1CCC:  MOVLW  65
1CCD:  MOVWF  3C
1CCE:  MOVLW  63
1CCF:  MOVWF  3D
1CD0:  CLRF   3E
.................... char  smstempalerta[]={"tmpwrn: "}; 
1CD1:  MOVLW  74
1CD2:  MOVWF  3F
1CD3:  MOVLW  6D
1CD4:  MOVWF  40
1CD5:  MOVLW  70
1CD6:  MOVWF  41
1CD7:  MOVLW  77
1CD8:  MOVWF  42
1CD9:  MOVLW  72
1CDA:  MOVWF  43
1CDB:  MOVLW  6E
1CDC:  MOVWF  44
1CDD:  MOVLW  3A
1CDE:  MOVWF  45
1CDF:  MOVLW  20
1CE0:  MOVWF  46
1CE1:  CLRF   47
.................... char  smstempgap[]={"tmpgap: "}; 
1CE2:  MOVLW  74
1CE3:  MOVWF  48
1CE4:  MOVLW  6D
1CE5:  MOVWF  49
1CE6:  MOVLW  70
1CE7:  MOVWF  4A
1CE8:  MOVLW  67
1CE9:  MOVWF  4B
1CEA:  MOVLW  61
1CEB:  MOVWF  4C
1CEC:  MOVLW  70
1CED:  MOVWF  4D
1CEE:  MOVLW  3A
1CEF:  MOVWF  4E
1CF0:  MOVLW  20
1CF1:  MOVWF  4F
1CF2:  CLRF   50
.................... char  smsreleon[]={"releon"}; 
1CF3:  MOVLW  72
1CF4:  MOVWF  51
1CF5:  MOVLW  65
1CF6:  MOVWF  52
1CF7:  MOVLW  6C
1CF8:  MOVWF  53
1CF9:  MOVLW  65
1CFA:  MOVWF  54
1CFB:  MOVLW  6F
1CFC:  MOVWF  55
1CFD:  MOVLW  6E
1CFE:  MOVWF  56
1CFF:  CLRF   57
.................... char  smsreleoff[]={"releoff"}; 
1D00:  MOVLW  72
1D01:  MOVWF  58
1D02:  MOVLW  65
1D03:  MOVWF  59
1D04:  MOVLW  6C
1D05:  MOVWF  5A
1D06:  MOVLW  65
1D07:  MOVWF  5B
1D08:  MOVLW  6F
1D09:  MOVWF  5C
1D0A:  MOVLW  66
1D0B:  MOVWF  5D
1D0C:  MOVWF  5E
1D0D:  CLRF   5F
....................  
....................  
.................... // Define's para ações 
....................  
.................... #define  buzzerligado() buzzer=1; ledalerta=1     // Buzzer em 0 = Kit e 1 = prototipo 
.................... #define  buzzerdesligado() buzzer=0; ledalerta=0 
....................  
.................... #define  coolermaximo() set_pwm1_duty(123); ledcooler=1 
.................... #define  coolermedio() set_pwm1_duty(80); ledcooler=1 
.................... #define  coolerdesligado() set_pwm1_duty(0); ledcooler=0 
.................... #define  mergligado() merg=1; ledmerg=1 
.................... #define  mergdesligado() merg=0; ledmerg=0 
.................... #define  releligado()   ledrele=1; rele=1 
.................... #define  reledesligado()   ledrele=0; rele=0 
.................... #define  plantaligada() ledon=1; flagPlantaLigada=TRUE 
.................... #define  plantadesligada() ledon=0; ledrele=0; merg=0; ledmerg=0; set_pwm1_duty(0); ledcooler=0;  buzzer=1; ledalerta=0; flagPlantaLigada=FALSE 
.................... #define  alterasetpoint TRUE 
.................... #define  naoalterasetpoint FALSE 
.................... #define  local  TRUE 
.................... #define  remoto FALSE 
....................  
....................  
....................  
....................  
....................  
.................... // deprecated 
.................... //float tempsup;                   // Temperatura máxima para ação da planta 
.................... //float tempinf;                   // Temperatura mínima para ação da planta 
.................... //char  smsligaralerta[]={"alertaon"}; 
.................... //char  smsdesligaralerta[]={"alertaoff"};    
.................... //char  smsreleon[]={"releon"}; 
.................... //char  smsreleoff[]={"releoff"}; 
....................  
.................... #include "script_int_timer1.h"      // script que trata timer1 responsável por temporizador 
.................... // int_timer1.h 
....................  
.................... int   conttime=0; 
1D0E:  CLRF   7D
....................  
.................... #int_timer1 
.................... void  tempolcd(void){ 
....................    if(conttime>0){ 
*
02D0:  MOVF   7D,F
02D1:  BTFSC  03.2
02D2:  GOTO   2D4
....................       conttime--; 
02D3:  DECF   7D,F
....................    } 
.................... } 
....................  
.................... #include "script_int_rda.h"      // script que trata timer1 responsável por temporizador 
.................... // int_rda.h 
....................  
02D4:  BCF    0C.0
02D5:  BCF    0A.3
02D6:  BCF    0A.4
02D7:  GOTO   025
.................... #int_rda 
.................... void  recebido(void){ 
.................... //!----------------------------------------------------------------------------------------------------------- 
.................... // Recebe os valores de rc_reg e incrementa as variaveis msg e cont  
....................    chegou=rc_reg;                      // A variavel chegou recebe os valores do registrador 
*
0352:  MOVF   1A,W
0353:  MOVWF  33
....................    if(chegou!='\n'&&chegou!='\r'){     // Checa caracteres de chegou diferentes de \r e \n 
0354:  MOVF   33,W
0355:  SUBLW  0A
0356:  BTFSC  03.2
0357:  GOTO   36E
0358:  MOVF   33,W
0359:  SUBLW  0D
035A:  BTFSC  03.2
035B:  GOTO   36E
....................       msg[cont]=chegou;                // msg é a variavel que recebe os caracteres 
035C:  MOVLW  A0
035D:  ADDWF  34,W
035E:  MOVWF  04
035F:  BCF    03.7
0360:  MOVF   33,W
0361:  MOVWF  00
....................       cont=cont+1;                     // incrementa a variável cont para os caracteres 
0362:  MOVLW  01
0363:  ADDWF  34,F
....................       if(flagSMS){                     // Caso identificado CMGR - Aciona FLAG para registrar a Mensagem SMS 
0364:  MOVF   58,F
0365:  BTFSC  03.2
0366:  GOTO   36E
....................          sms[contSMS]=chegou;          // Caso valida recebe valor da variavel chegou 
0367:  MOVLW  37
0368:  ADDWF  47,W
0369:  MOVWF  04
036A:  BCF    03.7
036B:  MOVF   33,W
036C:  MOVWF  00
....................          contSMS++;                    // Incrementa variavel contSMS formando a propria SMS recebida no modem 
036D:  INCF   47,F
....................          } 
....................    } 
....................     
.................... //!----------------------------------------------------------------------------------------------------------- 
.................... //Rotina que checa o CONT 
....................    if(chegou==0x0A&&cont!=0){          // Caso tenha chegado ao fim da linha 
036E:  MOVF   33,W
036F:  SUBLW  0A
0370:  BTFSS  03.2
0371:  GOTO   552
0372:  MOVF   34,F
0373:  BTFSC  03.2
0374:  GOTO   552
....................       msg[cont]='\0';                  // Zera a variavel msg 
0375:  MOVLW  A0
0376:  ADDWF  34,W
0377:  MOVWF  04
0378:  BCF    03.7
0379:  CLRF   00
....................       if(flagSMS){                     // Checa se flagSMS é TRUE 
037A:  MOVF   58,F
037B:  BTFSC  03.2
037C:  GOTO   384
....................          cont=0;                       // Zera o cont 
037D:  CLRF   34
....................          sms[contSMS]='\0';            // Zera o contSMS 
037E:  MOVLW  37
037F:  ADDWF  47,W
0380:  MOVWF  04
0381:  BCF    03.7
0382:  CLRF   00
....................          flagSMS=FALSE;                // Volta flagSMS ao estado inicial FALSE 
0383:  CLRF   58
....................       } 
....................       if(cont==2){                     //Testa se 2 vezes 0x0A é refetente a AT OK           
0384:  MOVF   34,W
0385:  SUBLW  02
0386:  BTFSS  03.2
0387:  GOTO   39A
....................          if(strncmp(msg,ok,2)==0){     // Compara a string msg ao valor de OK 
0388:  BSF    03.5
0389:  BSF    03.6
038A:  CLRF   29
038B:  MOVLW  A0
038C:  MOVWF  28
038D:  CLRF   2B
038E:  MOVLW  48
038F:  MOVWF  2A
0390:  MOVLW  02
0391:  MOVWF  2C
0392:  BCF    03.5
0393:  BCF    03.6
0394:  CALL   2D8
0395:  MOVF   78,F
0396:  BTFSS  03.2
0397:  GOTO   39A
....................             tipoComando=1;             // Caso seja igual OK seta tipoComando para 1 
0398:  MOVLW  01
0399:  MOVWF  36
....................          }         
....................       } 
....................       if(cont>8 && cont<16){           //Teste se 2 vezes 0x0A é referente a +CMTI   
039A:  MOVF   34,W
039B:  SUBLW  08
039C:  BTFSC  03.0
039D:  GOTO   4D2
039E:  MOVF   34,W
039F:  SUBLW  0F
03A0:  BTFSS  03.0
03A1:  GOTO   4D2
....................          if(strncmp(msg,cmti,5)==0){   // Compara string msg ao valor de +CMTI    ptr=strchr (s1,  c) 
03A2:  BSF    03.5
03A3:  BSF    03.6
03A4:  CLRF   29
03A5:  MOVLW  A0
03A6:  MOVWF  28
03A7:  CLRF   2B
03A8:  MOVLW  4B
03A9:  MOVWF  2A
03AA:  MOVLW  05
03AB:  MOVWF  2C
03AC:  BCF    03.5
03AD:  BCF    03.6
03AE:  CALL   2D8
03AF:  MOVF   78,F
03B0:  BTFSS  03.2
03B1:  GOTO   4D2
....................             cmtiIndex = atoi(strchr (msg,  ',')+1); 
03B2:  BSF    03.5
03B3:  BSF    03.6
03B4:  CLRF   29
03B5:  MOVLW  A0
03B6:  MOVWF  28
03B7:  MOVLW  2C
03B8:  MOVWF  2A
03B9:  BCF    03.5
03BA:  BCF    03.6
03BB:  CALL   32C
03BC:  MOVF   79,W
03BD:  BSF    03.5
03BE:  BSF    03.6
03BF:  MOVWF  29
03C0:  MOVF   78,W
03C1:  MOVWF  28
03C2:  MOVLW  01
03C3:  ADDWF  28,W
03C4:  MOVWF  2A
03C5:  MOVF   29,W
03C6:  MOVWF  2B
03C7:  BTFSC  03.0
03C8:  INCF   2B,F
03C9:  MOVF   2B,W
03CA:  MOVWF  2D
03CB:  MOVF   2A,W
03CC:  MOVWF  2C
*
04CC:  MOVF   78,W
04CD:  BCF    03.5
04CE:  BCF    03.6
04CF:  MOVWF  57
....................             tipoComando=2;             // Caso afirmativo seta tipoComando para 2 
04D0:  MOVLW  02
04D1:  MOVWF  36
....................          }         
....................       } 
....................       if(cont>46){          
04D2:  MOVF   34,W
04D3:  SUBLW  2E
04D4:  BTFSC  03.0
04D5:  GOTO   551
....................          if(strncmp(msg,cmgr,5)==0){   // Compara string msg ao valor de +CMGR 
04D6:  BSF    03.5
04D7:  BSF    03.6
04D8:  CLRF   29
04D9:  MOVLW  A0
04DA:  MOVWF  28
04DB:  CLRF   2B
04DC:  MOVLW  51
04DD:  MOVWF  2A
04DE:  MOVLW  05
04DF:  MOVWF  2C
04E0:  BCF    03.5
04E1:  BCF    03.6
04E2:  CALL   2D8
04E3:  MOVF   78,F
04E4:  BTFSS  03.2
04E5:  GOTO   551
....................             strncpy (fone,strchr (msg,',')+3, 10); 
04E6:  BSF    03.5
04E7:  BSF    03.6
04E8:  CLRF   29
04E9:  MOVLW  A0
04EA:  MOVWF  28
04EB:  MOVLW  2C
04EC:  MOVWF  2A
04ED:  BCF    03.5
04EE:  BCF    03.6
04EF:  CALL   32C
04F0:  MOVF   79,W
04F1:  BSF    03.5
04F2:  BSF    03.6
04F3:  MOVWF  29
04F4:  MOVF   78,W
04F5:  MOVWF  28
04F6:  MOVLW  03
04F7:  ADDWF  28,W
04F8:  MOVWF  2A
04F9:  MOVF   29,W
04FA:  MOVWF  2B
04FB:  BTFSC  03.0
04FC:  INCF   2B,F
04FD:  MOVLW  01
04FE:  MOVWF  2D
04FF:  MOVLW  10
0500:  MOVWF  2C
0501:  MOVF   2B,W
0502:  MOVWF  2F
0503:  MOVF   2A,W
0504:  MOVWF  2E
0505:  MOVLW  0A
0506:  MOVWF  30
....................             tipoComando=3;             // Caso afirmativo seta tipoComando para 3 
*
054A:  MOVLW  03
054B:  BCF    03.5
054C:  BCF    03.6
054D:  MOVWF  36
....................             contSMS=0;                 // Zera contSMS 
054E:  CLRF   47
....................             flagSMS=TRUE;              // Seta flagSMS para verdadeiro 
054F:  MOVLW  01
0550:  MOVWF  58
....................          }         
....................       } 
....................       cont=0;                          // Zera variável cont. 
0551:  CLRF   34
....................    }    
.................... } 
....................  
.................... #include "script_actions.h"         // script de acoes do sistema 
.................... // script_actions.h 
....................  
0552:  BCF    0C.5
0553:  BCF    0A.3
0554:  BCF    0A.4
0555:  GOTO   025
.................... void mudasetpoint(float novovalor){ 
....................    setpoint=novovalor; 
*
0753:  BSF    03.6
0754:  MOVF   69,W
0755:  BCF    03.6
0756:  MOVWF  61
0757:  BSF    03.6
0758:  MOVF   68,W
0759:  BCF    03.6
075A:  MOVWF  60
075B:  BSF    03.6
075C:  MOVF   67,W
075D:  BCF    03.6
075E:  MOVWF  5F
075F:  BSF    03.6
0760:  MOVF   66,W
0761:  BCF    03.6
0762:  MOVWF  5E
.................... } 
0763:  RETLW  00
....................  
.................... void aumentasetpoint(void){ 
....................    if(flagPlantaLigada){                           // Rotina para Aumentar Valor de SETPOINT Manualmente 
*
166F:  MOVF   59,F
1670:  BTFSC  03.2
1671:  GOTO   6AA
....................       mudasetpoint(setpoint+5); 
1672:  BCF    03.1
1673:  MOVF   61,W
1674:  BSF    03.5
1675:  BSF    03.6
1676:  MOVWF  1B
1677:  BCF    03.5
1678:  BCF    03.6
1679:  MOVF   60,W
167A:  BSF    03.5
167B:  BSF    03.6
167C:  MOVWF  1A
167D:  BCF    03.5
167E:  BCF    03.6
167F:  MOVF   5F,W
1680:  BSF    03.5
1681:  BSF    03.6
1682:  MOVWF  19
1683:  BCF    03.5
1684:  BCF    03.6
1685:  MOVF   5E,W
1686:  BSF    03.5
1687:  BSF    03.6
1688:  MOVWF  18
1689:  CLRF   1F
168A:  CLRF   1E
168B:  MOVLW  20
168C:  MOVWF  1D
168D:  MOVLW  81
168E:  MOVWF  1C
168F:  BCF    0A.4
1690:  BSF    0A.3
1691:  BCF    03.5
1692:  BCF    03.6
1693:  CALL   000
1694:  BSF    0A.4
1695:  BCF    0A.3
1696:  MOVF   77,W
1697:  BSF    03.6
1698:  MOVWF  60
1699:  MOVF   78,W
169A:  MOVWF  61
169B:  MOVF   79,W
169C:  MOVWF  62
169D:  MOVF   7A,W
169E:  MOVWF  63
169F:  MOVWF  69
16A0:  MOVF   62,W
16A1:  MOVWF  68
16A2:  MOVF   61,W
16A3:  MOVWF  67
16A4:  MOVF   60,W
16A5:  MOVWF  66
16A6:  BCF    0A.4
16A7:  BCF    03.6
16A8:  CALL   753
16A9:  BSF    0A.4
....................    } 
.................... } 
....................  
....................  
.................... void diminuisetpoint(void){                             // Rotina para Diminuir Valor de SETPOINT Manualmente 
....................    if(flagPlantaLigada){                                // Rotina para Aumentar Valor de SETPOINT Manualmente 
*
16AE:  MOVF   59,F
16AF:  BTFSC  03.2
16B0:  GOTO   6E9
....................       mudasetpoint(setpoint-5); 
16B1:  BSF    03.1
16B2:  MOVF   61,W
16B3:  BSF    03.5
16B4:  BSF    03.6
16B5:  MOVWF  1B
16B6:  BCF    03.5
16B7:  BCF    03.6
16B8:  MOVF   60,W
16B9:  BSF    03.5
16BA:  BSF    03.6
16BB:  MOVWF  1A
16BC:  BCF    03.5
16BD:  BCF    03.6
16BE:  MOVF   5F,W
16BF:  BSF    03.5
16C0:  BSF    03.6
16C1:  MOVWF  19
16C2:  BCF    03.5
16C3:  BCF    03.6
16C4:  MOVF   5E,W
16C5:  BSF    03.5
16C6:  BSF    03.6
16C7:  MOVWF  18
16C8:  CLRF   1F
16C9:  CLRF   1E
16CA:  MOVLW  20
16CB:  MOVWF  1D
16CC:  MOVLW  81
16CD:  MOVWF  1C
16CE:  BCF    0A.4
16CF:  BSF    0A.3
16D0:  BCF    03.5
16D1:  BCF    03.6
16D2:  CALL   000
16D3:  BSF    0A.4
16D4:  BCF    0A.3
16D5:  MOVF   77,W
16D6:  BSF    03.6
16D7:  MOVWF  60
16D8:  MOVF   78,W
16D9:  MOVWF  61
16DA:  MOVF   79,W
16DB:  MOVWF  62
16DC:  MOVF   7A,W
16DD:  MOVWF  63
16DE:  MOVWF  69
16DF:  MOVF   62,W
16E0:  MOVWF  68
16E1:  MOVF   61,W
16E2:  MOVWF  67
16E3:  MOVF   60,W
16E4:  MOVWF  66
16E5:  BCF    0A.4
16E6:  BCF    03.6
16E7:  CALL   753
16E8:  BSF    0A.4
....................    } 
.................... } 
....................  
....................  
.................... void checamodoop(void){ 
....................      firmwaremode=!firmwaremode; 
*
15E4:  MOVF   31,F
15E5:  BTFSC  03.2
15E6:  GOTO   5E9
15E7:  MOVLW  00
15E8:  GOTO   5EA
15E9:  MOVLW  01
15EA:  MOVWF  31
....................      limpa_lcd();                                        // Função Limpa conteúdo do LCD 
15EB:  BCF    0A.4
15EC:  CALL   586
15ED:  BSF    0A.4
....................      comando_lcd(0x80);                                  // Escolhe linha 1 do LCD 
15EE:  MOVLW  80
15EF:  BSF    03.6
15F0:  MOVWF  62
15F1:  BCF    0A.4
15F2:  BCF    03.6
15F3:  CALL   56A
15F4:  BSF    0A.4
....................      printf(escreve_lcd,"Modo Sensor");                // Escreve "TEXTO" no LCD 
15F5:  BSF    03.6
15F6:  CLRF   60
15F7:  MOVF   60,W
15F8:  BCF    0A.4
15F9:  BCF    03.6
15FA:  CALL   03E
15FB:  BSF    0A.4
15FC:  BSF    03.6
15FD:  INCF   60,F
15FE:  MOVWF  77
15FF:  BSF    03.5
1600:  MOVWF  10
1601:  BCF    0A.4
1602:  BCF    03.5
1603:  BCF    03.6
1604:  CALL   58C
1605:  BSF    0A.4
1606:  MOVLW  0B
1607:  BSF    03.6
1608:  SUBWF  60,W
1609:  BTFSS  03.2
160A:  GOTO   5F7
....................      comando_lcd(0xC0);                                  // Escolhe linha 2 do LCD 
160B:  MOVLW  C0
160C:  MOVWF  62
160D:  BCF    0A.4
160E:  BCF    03.6
160F:  CALL   56A
1610:  BSF    0A.4
....................      printf(escreve_lcd,":%u", firmwaremode); 
1611:  MOVLW  3A
1612:  BSF    03.5
1613:  BSF    03.6
1614:  MOVWF  10
1615:  BCF    0A.4
1616:  BCF    03.5
1617:  BCF    03.6
1618:  CALL   58C
1619:  BSF    0A.4
161A:  MOVF   31,W
161B:  BSF    03.6
161C:  MOVWF  60
161D:  MOVLW  1B
161E:  MOVWF  61
.................... } 
....................  
.................... void tempgaprecebido(void){ 
....................    if(flagPlantaLigada){ 
*
1337:  MOVF   59,F
1338:  BTFSC  03.2
1339:  GOTO   3B1
....................       tempgap=atof(&sms[8]); 
133A:  BSF    03.6
133B:  CLRF   63
133C:  MOVLW  3F
133D:  MOVWF  62
133E:  BCF    0A.4
133F:  BSF    0A.3
1340:  BCF    03.6
1341:  CALL   218
1342:  BSF    0A.4
1343:  BCF    0A.3
1344:  MOVF   7A,W
1345:  MOVWF  71
1346:  MOVF   79,W
1347:  MOVWF  70
1348:  MOVF   78,W
1349:  MOVWF  6F
134A:  MOVF   77,W
134B:  MOVWF  6E
....................        
....................       //LCD 
....................       limpa_lcd();                                        // Função Limpa conteúdo do LCD 
134C:  BCF    0A.4
134D:  CALL   586
134E:  BSF    0A.4
....................       comando_lcd(0x80);                                  // Escolhe linha 1 do LCD 
134F:  MOVLW  80
1350:  BSF    03.6
1351:  MOVWF  62
1352:  BCF    0A.4
1353:  BCF    03.6
1354:  CALL   56A
1355:  BSF    0A.4
....................       printf(escreve_lcd,"Novo TempGap");                 // Escreve "TEXTO" no LCD 
1356:  BSF    03.6
1357:  CLRF   60
1358:  MOVF   60,W
1359:  BCF    0A.4
135A:  BCF    03.6
135B:  CALL   04E
135C:  BSF    0A.4
135D:  BSF    03.6
135E:  INCF   60,F
135F:  MOVWF  77
1360:  BSF    03.5
1361:  MOVWF  10
1362:  BCF    0A.4
1363:  BCF    03.5
1364:  BCF    03.6
1365:  CALL   58C
1366:  BSF    0A.4
1367:  MOVLW  0C
1368:  BSF    03.6
1369:  SUBWF  60,W
136A:  BTFSS  03.2
136B:  GOTO   358
....................       comando_lcd(0xC0);                                  // Escolhe linha 2 do LCD 
136C:  MOVLW  C0
136D:  MOVWF  62
136E:  BCF    0A.4
136F:  BCF    03.6
1370:  CALL   56A
1371:  BSF    0A.4
....................       printf(escreve_lcd,"TempGap:%f  ", tempgap);  
1372:  BSF    03.6
1373:  CLRF   60
1374:  MOVF   60,W
1375:  BCF    0A.4
1376:  BCF    03.6
1377:  CALL   05F
1378:  BSF    0A.4
1379:  BSF    03.6
137A:  INCF   60,F
137B:  MOVWF  77
137C:  BSF    03.5
137D:  MOVWF  10
137E:  BCF    0A.4
137F:  BCF    03.5
1380:  BCF    03.6
1381:  CALL   58C
1382:  BSF    0A.4
1383:  MOVLW  08
1384:  BSF    03.6
1385:  SUBWF  60,W
1386:  BTFSS  03.2
1387:  GOTO   374
1388:  MOVLW  89
1389:  MOVWF  04
138A:  MOVF   71,W
138B:  MOVWF  66
138C:  MOVF   70,W
138D:  MOVWF  65
138E:  BCF    03.6
138F:  MOVF   6F,W
1390:  BSF    03.6
1391:  MOVWF  64
1392:  BCF    03.6
1393:  MOVF   6E,W
1394:  BSF    03.6
1395:  MOVWF  63
1396:  MOVLW  02
1397:  MOVWF  67
1398:  BCF    0A.4
1399:  BSF    0A.3
139A:  BCF    03.6
139B:  CALL   3DF
139C:  BSF    0A.4
139D:  BCF    0A.3
139E:  MOVLW  20
139F:  BSF    03.5
13A0:  BSF    03.6
13A1:  MOVWF  10
13A2:  BCF    0A.4
13A3:  BCF    03.5
13A4:  BCF    03.6
13A5:  CALL   58C
13A6:  BSF    0A.4
13A7:  MOVLW  20
13A8:  BSF    03.5
13A9:  BSF    03.6
13AA:  MOVWF  10
13AB:  BCF    0A.4
13AC:  BCF    03.5
13AD:  BCF    03.6
13AE:  CALL   58C
13AF:  BSF    0A.4
....................    }else{ 
13B0:  GOTO   458
....................       // apenas informe condição de planta desligada ao celular 
....................       printf("\n\r"); 
13B1:  MOVLW  0A
13B2:  BTFSS  0C.4
13B3:  GOTO   3B2
13B4:  MOVWF  19
13B5:  MOVLW  0D
13B6:  BTFSS  0C.4
13B7:  GOTO   3B6
13B8:  MOVWF  19
....................       printf("AT+CMGS=\"+55%s\"",fone); 
13B9:  BSF    03.6
13BA:  CLRF   60
13BB:  MOVF   60,W
13BC:  BCF    0A.4
13BD:  BCF    03.6
13BE:  CALL   070
13BF:  BSF    0A.4
13C0:  BSF    03.6
13C1:  INCF   60,F
13C2:  MOVWF  77
13C3:  BCF    03.6
13C4:  BTFSS  0C.4
13C5:  GOTO   3C4
13C6:  MOVWF  19
13C7:  MOVLW  0C
13C8:  BSF    03.6
13C9:  SUBWF  60,W
13CA:  BTFSS  03.2
13CB:  GOTO   3BB
13CC:  MOVLW  10
13CD:  MOVWF  04
13CE:  BSF    03.7
13CF:  MOVLW  00
13D0:  IORWF  00,W
13D1:  BTFSC  03.2
13D2:  GOTO   3DB
13D3:  MOVF   00,W
13D4:  BCF    03.6
13D5:  BTFSS  0C.4
13D6:  GOTO   3D5
13D7:  MOVWF  19
13D8:  INCF   04,F
13D9:  BSF    03.6
13DA:  GOTO   3CF
13DB:  MOVLW  22
13DC:  BCF    03.6
13DD:  BTFSS  0C.4
13DE:  GOTO   3DD
13DF:  MOVWF  19
....................       printf("\n\r"); 
13E0:  MOVLW  0A
13E1:  BTFSS  0C.4
13E2:  GOTO   3E1
13E3:  MOVWF  19
13E4:  MOVLW  0D
13E5:  BTFSS  0C.4
13E6:  GOTO   3E5
13E7:  MOVWF  19
....................       printf("Fatec TCC\n\r"); 
13E8:  BSF    03.6
13E9:  CLRF   60
13EA:  MOVF   60,W
13EB:  BCF    0A.4
13EC:  BCF    03.6
13ED:  CALL   084
13EE:  BSF    0A.4
13EF:  BSF    03.6
13F0:  INCF   60,F
13F1:  MOVWF  77
13F2:  BCF    03.6
13F3:  BTFSS  0C.4
13F4:  GOTO   3F3
13F5:  MOVWF  19
13F6:  MOVLW  0B
13F7:  BSF    03.6
13F8:  SUBWF  60,W
13F9:  BTFSS  03.2
13FA:  GOTO   3EA
....................       printf("Caso queira ligar por favor enviar setpoint ou comando ligar.\n\r"); 
13FB:  CLRF   60
13FC:  MOVF   60,W
13FD:  BCF    0A.4
13FE:  BCF    03.6
13FF:  CALL   094
1400:  BSF    0A.4
1401:  BSF    03.6
1402:  INCF   60,F
1403:  MOVWF  77
1404:  BCF    03.6
1405:  BTFSS  0C.4
1406:  GOTO   405
1407:  MOVWF  19
1408:  MOVLW  3F
1409:  BSF    03.6
140A:  SUBWF  60,W
140B:  BTFSS  03.2
140C:  GOTO   3FC
....................       printf("%c", fim); 
140D:  BCF    03.6
140E:  MOVF   35,W
140F:  BTFSS  0C.4
1410:  GOTO   40F
1411:  MOVWF  19
....................       delay_ms(200); 
1412:  MOVLW  C8
1413:  BSF    03.5
1414:  BSF    03.6
1415:  MOVWF  11
1416:  BCF    0A.4
1417:  BCF    03.5
1418:  BCF    03.6
1419:  CALL   556
141A:  BSF    0A.4
....................        
....................       // LCD 
....................       limpa_lcd();                                             // Função Limpa conteúdo do LCD 
141B:  BCF    0A.4
141C:  CALL   586
141D:  BSF    0A.4
....................       comando_lcd(0x80);                                       // Escolhe linha 1 do LCD 
141E:  MOVLW  80
141F:  BSF    03.6
1420:  MOVWF  62
1421:  BCF    0A.4
1422:  BCF    03.6
1423:  CALL   56A
1424:  BSF    0A.4
....................       printf(escreve_lcd, "Ped. TempGap"); 
1425:  BSF    03.6
1426:  CLRF   60
1427:  MOVF   60,W
1428:  BCF    0A.4
1429:  BCF    03.6
142A:  CALL   0D8
142B:  BSF    0A.4
142C:  BSF    03.6
142D:  INCF   60,F
142E:  MOVWF  77
142F:  BSF    03.5
1430:  MOVWF  10
1431:  BCF    0A.4
1432:  BCF    03.5
1433:  BCF    03.6
1434:  CALL   58C
1435:  BSF    0A.4
1436:  MOVLW  0C
1437:  BSF    03.6
1438:  SUBWF  60,W
1439:  BTFSS  03.2
143A:  GOTO   427
....................       comando_lcd(0xC0);                                       // Escolhe linha 2 do LCD 
143B:  MOVLW  C0
143C:  MOVWF  62
143D:  BCF    0A.4
143E:  BCF    03.6
143F:  CALL   56A
1440:  BSF    0A.4
....................       printf(escreve_lcd, "Planta desligada"); 
1441:  BSF    03.6
1442:  CLRF   60
1443:  MOVF   60,W
1444:  BCF    0A.4
1445:  BCF    03.6
1446:  CALL   0E9
1447:  BSF    0A.4
1448:  BSF    03.6
1449:  INCF   60,F
144A:  MOVWF  77
144B:  BSF    03.5
144C:  MOVWF  10
144D:  BCF    0A.4
144E:  BCF    03.5
144F:  BCF    03.6
1450:  CALL   58C
1451:  BSF    0A.4
1452:  MOVLW  10
1453:  BSF    03.6
1454:  SUBWF  60,W
1455:  BTFSS  03.2
1456:  GOTO   443
1457:  BCF    03.6
....................    }      
....................    conttime=8; 
1458:  MOVLW  08
1459:  MOVWF  7D
145A:  CLRF   28
145B:  BTFSC  0B.7
145C:  BSF    28.7
145D:  BCF    0B.7
.................... } 
....................  
....................  
....................  
.................... void tempalertarecebido(void){ 
....................    if(flagPlantaLigada){ 
*
1473:  MOVF   59,F
1474:  BTFSC  03.2
1475:  GOTO   4E6
....................       tempalerta=atof(&sms[8]); 
1476:  BSF    03.6
1477:  CLRF   63
1478:  MOVLW  3F
1479:  MOVWF  62
147A:  BCF    0A.4
147B:  BSF    0A.3
147C:  BCF    03.6
147D:  CALL   218
147E:  BSF    0A.4
147F:  BCF    0A.3
1480:  MOVF   7A,W
1481:  MOVWF  75
1482:  MOVF   79,W
1483:  MOVWF  74
1484:  MOVF   78,W
1485:  MOVWF  73
1486:  MOVF   77,W
1487:  MOVWF  72
....................       //LCD 
....................       limpa_lcd();                                        // Função Limpa conteúdo do LCD 
1488:  BCF    0A.4
1489:  CALL   586
148A:  BSF    0A.4
....................       comando_lcd(0x80);                                  // Escolhe linha 1 do LCD 
148B:  MOVLW  80
148C:  BSF    03.6
148D:  MOVWF  62
148E:  BCF    0A.4
148F:  BCF    03.6
1490:  CALL   56A
1491:  BSF    0A.4
....................       printf(escreve_lcd,"Novo TempAlerta");                // Escreve "TEXTO" no LCD 
1492:  BSF    03.6
1493:  CLRF   60
1494:  MOVF   60,W
1495:  BCF    0A.4
1496:  BCF    03.6
1497:  CALL   0FE
1498:  BSF    0A.4
1499:  BSF    03.6
149A:  INCF   60,F
149B:  MOVWF  77
149C:  BSF    03.5
149D:  MOVWF  10
149E:  BCF    0A.4
149F:  BCF    03.5
14A0:  BCF    03.6
14A1:  CALL   58C
14A2:  BSF    0A.4
14A3:  MOVLW  0F
14A4:  BSF    03.6
14A5:  SUBWF  60,W
14A6:  BTFSS  03.2
14A7:  GOTO   494
....................       comando_lcd(0xC0);                                  // Escolhe linha 1 do LCD 
14A8:  MOVLW  C0
14A9:  MOVWF  62
14AA:  BCF    0A.4
14AB:  BCF    03.6
14AC:  CALL   56A
14AD:  BSF    0A.4
....................       printf(escreve_lcd,"TempAlerta:%f    ", tempalerta);  
14AE:  BSF    03.6
14AF:  CLRF   60
14B0:  MOVF   60,W
14B1:  BCF    0A.4
14B2:  BCF    03.6
14B3:  CALL   112
14B4:  BSF    0A.4
14B5:  BSF    03.6
14B6:  INCF   60,F
14B7:  MOVWF  77
14B8:  BSF    03.5
14B9:  MOVWF  10
14BA:  BCF    0A.4
14BB:  BCF    03.5
14BC:  BCF    03.6
14BD:  CALL   58C
14BE:  BSF    0A.4
14BF:  MOVLW  0B
14C0:  BSF    03.6
14C1:  SUBWF  60,W
14C2:  BTFSS  03.2
14C3:  GOTO   4B0
14C4:  MOVLW  89
14C5:  MOVWF  04
14C6:  MOVF   75,W
14C7:  MOVWF  66
14C8:  MOVF   74,W
14C9:  MOVWF  65
14CA:  MOVF   73,W
14CB:  MOVWF  64
14CC:  MOVF   72,W
14CD:  MOVWF  63
14CE:  MOVLW  02
14CF:  MOVWF  67
14D0:  BCF    0A.4
14D1:  BSF    0A.3
14D2:  BCF    03.6
14D3:  CALL   3DF
14D4:  BSF    0A.4
14D5:  BCF    0A.3
14D6:  MOVLW  04
14D7:  BSF    03.6
14D8:  MOVWF  61
14D9:  MOVLW  20
14DA:  BSF    03.5
14DB:  MOVWF  10
14DC:  BCF    0A.4
14DD:  BCF    03.5
14DE:  BCF    03.6
14DF:  CALL   58C
14E0:  BSF    0A.4
14E1:  BSF    03.6
14E2:  DECFSZ 61,F
14E3:  GOTO   4D9
....................    }else{ 
14E4:  GOTO   59E
14E5:  BCF    03.6
....................       printf("\n\r"); 
14E6:  MOVLW  0A
14E7:  BTFSS  0C.4
14E8:  GOTO   4E7
14E9:  MOVWF  19
14EA:  MOVLW  0D
14EB:  BTFSS  0C.4
14EC:  GOTO   4EB
14ED:  MOVWF  19
....................       printf("AT+CMGS=\"+55%s\"",fone); 
14EE:  BSF    03.6
14EF:  CLRF   60
14F0:  MOVF   60,W
14F1:  BCF    0A.4
14F2:  BCF    03.6
14F3:  CALL   070
14F4:  BSF    0A.4
14F5:  BSF    03.6
14F6:  INCF   60,F
14F7:  MOVWF  77
14F8:  BCF    03.6
14F9:  BTFSS  0C.4
14FA:  GOTO   4F9
14FB:  MOVWF  19
14FC:  MOVLW  0C
14FD:  BSF    03.6
14FE:  SUBWF  60,W
14FF:  BTFSS  03.2
1500:  GOTO   4F0
1501:  MOVLW  10
1502:  MOVWF  04
1503:  BSF    03.7
1504:  MOVLW  00
1505:  IORWF  00,W
1506:  BTFSC  03.2
1507:  GOTO   510
1508:  MOVF   00,W
1509:  BCF    03.6
150A:  BTFSS  0C.4
150B:  GOTO   50A
150C:  MOVWF  19
150D:  INCF   04,F
150E:  BSF    03.6
150F:  GOTO   504
1510:  MOVLW  22
1511:  BCF    03.6
1512:  BTFSS  0C.4
1513:  GOTO   512
1514:  MOVWF  19
....................       printf("\n\r"); 
1515:  MOVLW  0A
1516:  BTFSS  0C.4
1517:  GOTO   516
1518:  MOVWF  19
1519:  MOVLW  0D
151A:  BTFSS  0C.4
151B:  GOTO   51A
151C:  MOVWF  19
....................       printf("Fatec TCC\n\r"); 
151D:  BSF    03.6
151E:  CLRF   60
151F:  MOVF   60,W
1520:  BCF    0A.4
1521:  BCF    03.6
1522:  CALL   084
1523:  BSF    0A.4
1524:  BSF    03.6
1525:  INCF   60,F
1526:  MOVWF  77
1527:  BCF    03.6
1528:  BTFSS  0C.4
1529:  GOTO   528
152A:  MOVWF  19
152B:  MOVLW  0B
152C:  BSF    03.6
152D:  SUBWF  60,W
152E:  BTFSS  03.2
152F:  GOTO   51F
....................       printf("Status da Planta: DESLIGADA.\n\r"); 
1530:  CLRF   60
1531:  MOVF   60,W
1532:  BCF    0A.4
1533:  BCF    03.6
1534:  CALL   124
1535:  BSF    0A.4
1536:  BSF    03.6
1537:  INCF   60,F
1538:  MOVWF  77
1539:  BCF    03.6
153A:  BTFSS  0C.4
153B:  GOTO   53A
153C:  MOVWF  19
153D:  MOVLW  1E
153E:  BSF    03.6
153F:  SUBWF  60,W
1540:  BTFSS  03.2
1541:  GOTO   531
....................       printf("Caso queira ligar por favor enviar setpoint ou comando ligar.\n\r"); 
1542:  CLRF   60
1543:  MOVF   60,W
1544:  BCF    0A.4
1545:  BCF    03.6
1546:  CALL   094
1547:  BSF    0A.4
1548:  BSF    03.6
1549:  INCF   60,F
154A:  MOVWF  77
154B:  BCF    03.6
154C:  BTFSS  0C.4
154D:  GOTO   54C
154E:  MOVWF  19
154F:  MOVLW  3F
1550:  BSF    03.6
1551:  SUBWF  60,W
1552:  BTFSS  03.2
1553:  GOTO   543
....................       printf("%c", fim); 
1554:  BCF    03.6
1555:  MOVF   35,W
1556:  BTFSS  0C.4
1557:  GOTO   556
1558:  MOVWF  19
....................       delay_ms(200); 
1559:  MOVLW  C8
155A:  BSF    03.5
155B:  BSF    03.6
155C:  MOVWF  11
155D:  BCF    0A.4
155E:  BCF    03.5
155F:  BCF    03.6
1560:  CALL   556
1561:  BSF    0A.4
....................       // LCD 
....................       limpa_lcd();                                             // Função Limpa conteúdo do LCD 
1562:  BCF    0A.4
1563:  CALL   586
1564:  BSF    0A.4
....................       comando_lcd(0x80);                                       // Escolhe linha 1 do LCD 
1565:  MOVLW  80
1566:  BSF    03.6
1567:  MOVWF  62
1568:  BCF    0A.4
1569:  BCF    03.6
156A:  CALL   56A
156B:  BSF    0A.4
....................       printf(escreve_lcd, "Ped. TempAlerta"); 
156C:  BSF    03.6
156D:  CLRF   60
156E:  MOVF   60,W
156F:  BCF    0A.4
1570:  BCF    03.6
1571:  CALL   147
1572:  BSF    0A.4
1573:  BSF    03.6
1574:  INCF   60,F
1575:  MOVWF  77
1576:  BSF    03.5
1577:  MOVWF  10
1578:  BCF    0A.4
1579:  BCF    03.5
157A:  BCF    03.6
157B:  CALL   58C
157C:  BSF    0A.4
157D:  MOVLW  0F
157E:  BSF    03.6
157F:  SUBWF  60,W
1580:  BTFSS  03.2
1581:  GOTO   56E
....................       comando_lcd(0xC0);                                       // Escolhe linha 2 do LCD 
1582:  MOVLW  C0
1583:  MOVWF  62
1584:  BCF    0A.4
1585:  BCF    03.6
1586:  CALL   56A
1587:  BSF    0A.4
....................       printf(escreve_lcd, "Planta desligada"); 
1588:  BSF    03.6
1589:  CLRF   60
158A:  MOVF   60,W
158B:  BCF    0A.4
158C:  BCF    03.6
158D:  CALL   0E9
158E:  BSF    0A.4
158F:  BSF    03.6
1590:  INCF   60,F
1591:  MOVWF  77
1592:  BSF    03.5
1593:  MOVWF  10
1594:  BCF    0A.4
1595:  BCF    03.5
1596:  BCF    03.6
1597:  CALL   58C
1598:  BSF    0A.4
1599:  MOVLW  10
159A:  BSF    03.6
159B:  SUBWF  60,W
159C:  BTFSS  03.2
159D:  GOTO   58A
....................    }      
....................    conttime=8; 
159E:  MOVLW  08
159F:  MOVWF  7D
15A0:  BCF    03.6
.................... } 
....................  
....................  
....................  
.................... void enviatemp(void){                              
....................    if(flagPlantaLigada){ 
*
116B:  MOVF   59,F
116C:  BTFSC  03.2
116D:  GOTO   26A
....................       //LCD 
....................       limpa_lcd();                                             // Função Limpa conteúdo do LCD 
116E:  BCF    0A.4
116F:  CALL   586
1170:  BSF    0A.4
....................       comando_lcd(0x80);                                       // Escolhe linha 1 do LCD 
1171:  MOVLW  80
1172:  BSF    03.6
1173:  MOVWF  62
1174:  BCF    0A.4
1175:  BCF    03.6
1176:  CALL   56A
1177:  BSF    0A.4
....................       printf(escreve_lcd, "Env: %s", fone); 
1178:  BSF    03.6
1179:  CLRF   60
117A:  MOVF   60,W
117B:  BCF    0A.4
117C:  BCF    03.6
117D:  CALL   15B
117E:  BSF    0A.4
117F:  BSF    03.6
1180:  INCF   60,F
1181:  MOVWF  77
1182:  BSF    03.5
1183:  MOVWF  10
1184:  BCF    0A.4
1185:  BCF    03.5
1186:  BCF    03.6
1187:  CALL   58C
1188:  BSF    0A.4
1189:  MOVLW  05
118A:  BSF    03.6
118B:  SUBWF  60,W
118C:  BTFSS  03.2
118D:  GOTO   17A
118E:  MOVLW  10
118F:  MOVWF  04
1190:  BSF    03.7
1191:  MOVLW  00
1192:  IORWF  00,W
1193:  BTFSC  03.2
1194:  GOTO   1AB
1195:  CLRF   62
1196:  MOVF   04,W
1197:  MOVWF  61
1198:  BCF    62.0
1199:  BTFSC  03.7
119A:  BSF    62.0
119B:  MOVF   00,W
119C:  BSF    03.5
119D:  MOVWF  10
119E:  BCF    0A.4
119F:  BCF    03.5
11A0:  BCF    03.6
11A1:  CALL   58C
11A2:  BSF    0A.4
11A3:  BSF    03.6
11A4:  MOVF   61,W
11A5:  MOVWF  04
11A6:  BCF    03.7
11A7:  BTFSC  62.0
11A8:  BSF    03.7
11A9:  INCF   04,F
11AA:  GOTO   191
....................       comando_lcd(0xC0);                                       // Escolhe linha 2 do LCD 
11AB:  MOVLW  C0
11AC:  MOVWF  62
11AD:  BCF    0A.4
11AE:  BCF    03.6
11AF:  CALL   56A
11B0:  BSF    0A.4
....................       printf(escreve_lcd, "Temp: %f",temp); 
11B1:  BSF    03.6
11B2:  CLRF   60
11B3:  MOVF   60,W
11B4:  BCF    0A.4
11B5:  BCF    03.6
11B6:  CALL   167
11B7:  BSF    0A.4
11B8:  BSF    03.6
11B9:  INCF   60,F
11BA:  MOVWF  77
11BB:  BSF    03.5
11BC:  MOVWF  10
11BD:  BCF    0A.4
11BE:  BCF    03.5
11BF:  BCF    03.6
11C0:  CALL   58C
11C1:  BSF    0A.4
11C2:  MOVLW  06
11C3:  BSF    03.6
11C4:  SUBWF  60,W
11C5:  BTFSS  03.2
11C6:  GOTO   1B3
11C7:  MOVLW  89
11C8:  MOVWF  04
11C9:  BCF    03.6
11CA:  MOVF   69,W
11CB:  BSF    03.6
11CC:  MOVWF  66
11CD:  BCF    03.6
11CE:  MOVF   68,W
11CF:  BSF    03.6
11D0:  MOVWF  65
11D1:  BCF    03.6
11D2:  MOVF   67,W
11D3:  BSF    03.6
11D4:  MOVWF  64
11D5:  BCF    03.6
11D6:  MOVF   66,W
11D7:  BSF    03.6
11D8:  MOVWF  63
11D9:  MOVLW  02
11DA:  MOVWF  67
11DB:  BCF    0A.4
11DC:  BSF    0A.3
11DD:  BCF    03.6
11DE:  CALL   3DF
11DF:  BSF    0A.4
11E0:  BCF    0A.3
....................       conttime=2;                                              // A cada unidade incrementada o valor de tempo será de 250ms 
11E1:  MOVLW  02
11E2:  MOVWF  7D
....................       //SMS 
....................       printf("\n\r"); 
11E3:  MOVLW  0A
11E4:  BTFSS  0C.4
11E5:  GOTO   1E4
11E6:  MOVWF  19
11E7:  MOVLW  0D
11E8:  BTFSS  0C.4
11E9:  GOTO   1E8
11EA:  MOVWF  19
....................       printf("AT+CMGS=\"+55%s\"",fone); 
11EB:  BSF    03.6
11EC:  CLRF   60
11ED:  MOVF   60,W
11EE:  BCF    0A.4
11EF:  BCF    03.6
11F0:  CALL   070
11F1:  BSF    0A.4
11F2:  BSF    03.6
11F3:  INCF   60,F
11F4:  MOVWF  77
11F5:  BCF    03.6
11F6:  BTFSS  0C.4
11F7:  GOTO   1F6
11F8:  MOVWF  19
11F9:  MOVLW  0C
11FA:  BSF    03.6
11FB:  SUBWF  60,W
11FC:  BTFSS  03.2
11FD:  GOTO   1ED
11FE:  MOVLW  10
11FF:  MOVWF  04
1200:  BSF    03.7
1201:  MOVLW  00
1202:  IORWF  00,W
1203:  BTFSC  03.2
1204:  GOTO   20D
1205:  MOVF   00,W
1206:  BCF    03.6
1207:  BTFSS  0C.4
1208:  GOTO   207
1209:  MOVWF  19
120A:  INCF   04,F
120B:  BSF    03.6
120C:  GOTO   201
120D:  MOVLW  22
120E:  BCF    03.6
120F:  BTFSS  0C.4
1210:  GOTO   20F
1211:  MOVWF  19
....................       printf("\n\r"); 
1212:  MOVLW  0A
1213:  BTFSS  0C.4
1214:  GOTO   213
1215:  MOVWF  19
1216:  MOVLW  0D
1217:  BTFSS  0C.4
1218:  GOTO   217
1219:  MOVWF  19
....................       conttime=1;  
121A:  MOVLW  01
121B:  MOVWF  7D
....................       printf("Fatec TCC\n\r"); 
121C:  BSF    03.6
121D:  CLRF   60
121E:  MOVF   60,W
121F:  BCF    0A.4
1220:  BCF    03.6
1221:  CALL   084
1222:  BSF    0A.4
1223:  BSF    03.6
1224:  INCF   60,F
1225:  MOVWF  77
1226:  BCF    03.6
1227:  BTFSS  0C.4
1228:  GOTO   227
1229:  MOVWF  19
122A:  MOVLW  0B
122B:  BSF    03.6
122C:  SUBWF  60,W
122D:  BTFSS  03.2
122E:  GOTO   21E
....................       printf("Temperatura: %f", temp); 
122F:  CLRF   60
1230:  MOVF   60,W
1231:  BCF    0A.4
1232:  BCF    03.6
1233:  CALL   174
1234:  BSF    0A.4
1235:  BSF    03.6
1236:  INCF   60,F
1237:  MOVWF  77
1238:  BCF    03.6
1239:  BTFSS  0C.4
123A:  GOTO   239
123B:  MOVWF  19
123C:  MOVLW  0D
123D:  BSF    03.6
123E:  SUBWF  60,W
123F:  BTFSS  03.2
1240:  GOTO   230
1241:  MOVLW  89
1242:  MOVWF  04
1243:  BCF    03.6
1244:  MOVF   69,W
1245:  BSF    03.6
1246:  MOVWF  64
1247:  BCF    03.6
1248:  MOVF   68,W
1249:  BSF    03.6
124A:  MOVWF  63
124B:  BCF    03.6
124C:  MOVF   67,W
124D:  BSF    03.6
124E:  MOVWF  62
124F:  BCF    03.6
1250:  MOVF   66,W
1251:  BSF    03.6
1252:  MOVWF  61
1253:  MOVLW  02
1254:  MOVWF  65
1255:  BCF    0A.4
1256:  BSF    0A.3
1257:  BCF    03.6
1258:  GOTO   6BF
1259:  BSF    0A.4
125A:  BCF    0A.3
....................       printf("\n\r"); 
125B:  MOVLW  0A
125C:  BTFSS  0C.4
125D:  GOTO   25C
125E:  MOVWF  19
125F:  MOVLW  0D
1260:  BTFSS  0C.4
1261:  GOTO   260
1262:  MOVWF  19
....................       conttime=1;  
1263:  MOVLW  01
1264:  MOVWF  7D
....................       printf("%c", fim);     
1265:  MOVF   35,W
1266:  BTFSS  0C.4
1267:  GOTO   266
1268:  MOVWF  19
....................    }else{ 
1269:  GOTO   31C
....................       // SMS 
....................       // apenas informe condição de planta desligada ao celular 
....................       printf("\n\r"); 
126A:  MOVLW  0A
126B:  BTFSS  0C.4
126C:  GOTO   26B
126D:  MOVWF  19
126E:  MOVLW  0D
126F:  BTFSS  0C.4
1270:  GOTO   26F
1271:  MOVWF  19
....................       printf("AT+CMGS=\"+55%s\"",fone); 
1272:  BSF    03.6
1273:  CLRF   60
1274:  MOVF   60,W
1275:  BCF    0A.4
1276:  BCF    03.6
1277:  CALL   070
1278:  BSF    0A.4
1279:  BSF    03.6
127A:  INCF   60,F
127B:  MOVWF  77
127C:  BCF    03.6
127D:  BTFSS  0C.4
127E:  GOTO   27D
127F:  MOVWF  19
1280:  MOVLW  0C
1281:  BSF    03.6
1282:  SUBWF  60,W
1283:  BTFSS  03.2
1284:  GOTO   274
1285:  MOVLW  10
1286:  MOVWF  04
1287:  BSF    03.7
1288:  MOVLW  00
1289:  IORWF  00,W
128A:  BTFSC  03.2
128B:  GOTO   294
128C:  MOVF   00,W
128D:  BCF    03.6
128E:  BTFSS  0C.4
128F:  GOTO   28E
1290:  MOVWF  19
1291:  INCF   04,F
1292:  BSF    03.6
1293:  GOTO   288
1294:  MOVLW  22
1295:  BCF    03.6
1296:  BTFSS  0C.4
1297:  GOTO   296
1298:  MOVWF  19
....................       printf("\n\r"); 
1299:  MOVLW  0A
129A:  BTFSS  0C.4
129B:  GOTO   29A
129C:  MOVWF  19
129D:  MOVLW  0D
129E:  BTFSS  0C.4
129F:  GOTO   29E
12A0:  MOVWF  19
....................       printf("Fatec TCC\n\r"); 
12A1:  BSF    03.6
12A2:  CLRF   60
12A3:  MOVF   60,W
12A4:  BCF    0A.4
12A5:  BCF    03.6
12A6:  CALL   084
12A7:  BSF    0A.4
12A8:  BSF    03.6
12A9:  INCF   60,F
12AA:  MOVWF  77
12AB:  BCF    03.6
12AC:  BTFSS  0C.4
12AD:  GOTO   2AC
12AE:  MOVWF  19
12AF:  MOVLW  0B
12B0:  BSF    03.6
12B1:  SUBWF  60,W
12B2:  BTFSS  03.2
12B3:  GOTO   2A3
....................       printf("Status da Planta: DESLIGADA.\n\r"); 
12B4:  CLRF   60
12B5:  MOVF   60,W
12B6:  BCF    0A.4
12B7:  BCF    03.6
12B8:  CALL   124
12B9:  BSF    0A.4
12BA:  BSF    03.6
12BB:  INCF   60,F
12BC:  MOVWF  77
12BD:  BCF    03.6
12BE:  BTFSS  0C.4
12BF:  GOTO   2BE
12C0:  MOVWF  19
12C1:  MOVLW  1E
12C2:  BSF    03.6
12C3:  SUBWF  60,W
12C4:  BTFSS  03.2
12C5:  GOTO   2B5
....................       printf("Caso queira ligar por favor enviar setpoint ou comando ligar.\n\r"); 
12C6:  CLRF   60
12C7:  MOVF   60,W
12C8:  BCF    0A.4
12C9:  BCF    03.6
12CA:  CALL   094
12CB:  BSF    0A.4
12CC:  BSF    03.6
12CD:  INCF   60,F
12CE:  MOVWF  77
12CF:  BCF    03.6
12D0:  BTFSS  0C.4
12D1:  GOTO   2D0
12D2:  MOVWF  19
12D3:  MOVLW  3F
12D4:  BSF    03.6
12D5:  SUBWF  60,W
12D6:  BTFSS  03.2
12D7:  GOTO   2C7
....................       printf("%c", fim); 
12D8:  BCF    03.6
12D9:  MOVF   35,W
12DA:  BTFSS  0C.4
12DB:  GOTO   2DA
12DC:  MOVWF  19
....................       conttime=1;  
12DD:  MOVLW  01
12DE:  MOVWF  7D
....................       // LCD 
....................       limpa_lcd();                                             // Função Limpa conteúdo do LCD 
12DF:  BCF    0A.4
12E0:  CALL   586
12E1:  BSF    0A.4
....................       comando_lcd(0x80);                                       // Escolhe linha 1 do LCD 
12E2:  MOVLW  80
12E3:  BSF    03.6
12E4:  MOVWF  62
12E5:  BCF    0A.4
12E6:  BCF    03.6
12E7:  CALL   56A
12E8:  BSF    0A.4
....................       printf(escreve_lcd, "Solicit. Temp"); 
12E9:  BSF    03.6
12EA:  CLRF   60
12EB:  MOVF   60,W
12EC:  BCF    0A.4
12ED:  BCF    03.6
12EE:  CALL   188
12EF:  BSF    0A.4
12F0:  BSF    03.6
12F1:  INCF   60,F
12F2:  MOVWF  77
12F3:  BSF    03.5
12F4:  MOVWF  10
12F5:  BCF    0A.4
12F6:  BCF    03.5
12F7:  BCF    03.6
12F8:  CALL   58C
12F9:  BSF    0A.4
12FA:  MOVLW  0D
12FB:  BSF    03.6
12FC:  SUBWF  60,W
12FD:  BTFSS  03.2
12FE:  GOTO   2EB
....................       comando_lcd(0xC0);                                       // Escolhe linha 2 do LCD 
12FF:  MOVLW  C0
1300:  MOVWF  62
1301:  BCF    0A.4
1302:  BCF    03.6
1303:  CALL   56A
1304:  BSF    0A.4
....................       printf(escreve_lcd, "Planta desligada"); 
1305:  BSF    03.6
1306:  CLRF   60
1307:  MOVF   60,W
1308:  BCF    0A.4
1309:  BCF    03.6
130A:  CALL   0E9
130B:  BSF    0A.4
130C:  BSF    03.6
130D:  INCF   60,F
130E:  MOVWF  77
130F:  BSF    03.5
1310:  MOVWF  10
1311:  BCF    0A.4
1312:  BCF    03.5
1313:  BCF    03.6
1314:  CALL   58C
1315:  BSF    0A.4
1316:  MOVLW  10
1317:  BSF    03.6
1318:  SUBWF  60,W
1319:  BTFSS  03.2
131A:  GOTO   307
131B:  BCF    03.6
....................    } 
....................    conttime=8; 
131C:  MOVLW  08
131D:  MOVWF  7D
131E:  CLRF   28
131F:  BTFSC  0B.7
1320:  BSF    28.7
1321:  BCF    0B.7
.................... } 
....................  
....................  
....................  
.................... void ligaplanta(boolean flagAlteraSetpoint, boolean flagTipoAcao){ 
....................    if(flagAlteraSetpoint==alterasetpoint){ 
*
0CF7:  BSF    03.6
0CF8:  DECFSZ 60,W
0CF9:  GOTO   515
....................       mudasetpoint(atof(&sms[8])); 
0CFA:  CLRF   63
0CFB:  MOVLW  3F
0CFC:  MOVWF  62
0CFD:  BCF    03.6
0CFE:  CALL   218
0CFF:  MOVF   77,W
0D00:  BSF    03.6
0D01:  MOVWF  62
0D02:  MOVF   78,W
0D03:  MOVWF  63
0D04:  MOVF   79,W
0D05:  MOVWF  64
0D06:  MOVF   7A,W
0D07:  MOVWF  65
0D08:  MOVWF  69
0D09:  MOVF   64,W
0D0A:  MOVWF  68
0D0B:  MOVF   63,W
0D0C:  MOVWF  67
0D0D:  MOVF   62,W
0D0E:  MOVWF  66
0D0F:  BCF    0A.3
0D10:  BCF    03.6
0D11:  CALL   753
0D12:  BSF    0A.3
....................    }else{ 
0D13:  GOTO   545
0D14:  BSF    03.6
....................       if(setpoint!=0){  
0D15:  BCF    03.6
0D16:  MOVF   61,W
0D17:  BSF    03.6
0D18:  MOVWF  67
0D19:  BCF    03.6
0D1A:  MOVF   60,W
0D1B:  BSF    03.6
0D1C:  MOVWF  66
0D1D:  BCF    03.6
0D1E:  MOVF   5F,W
0D1F:  BSF    03.6
0D20:  MOVWF  65
0D21:  BCF    03.6
0D22:  MOVF   5E,W
0D23:  BSF    03.6
0D24:  MOVWF  64
0D25:  CLRF   6B
0D26:  CLRF   6A
0D27:  CLRF   69
0D28:  CLRF   68
0D29:  BCF    0A.3
0D2A:  BCF    03.6
0D2B:  CALL   764
0D2C:  BSF    0A.3
0D2D:  BTFSS  03.2
....................          // do nothing 
....................       }else{ 
0D2E:  GOTO   542
....................          mudasetpoint(tempinicial); 
0D2F:  MOVF   6D,W
0D30:  BSF    03.6
0D31:  MOVWF  69
0D32:  BCF    03.6
0D33:  MOVF   6C,W
0D34:  BSF    03.6
0D35:  MOVWF  68
0D36:  BCF    03.6
0D37:  MOVF   6B,W
0D38:  BSF    03.6
0D39:  MOVWF  67
0D3A:  BCF    03.6
0D3B:  MOVF   6A,W
0D3C:  BSF    03.6
0D3D:  MOVWF  66
0D3E:  BCF    0A.3
0D3F:  BCF    03.6
0D40:  CALL   753
0D41:  BSF    0A.3
....................       } 
....................       limpa_lcd();                                         
0D42:  BCF    0A.3
0D43:  CALL   586
0D44:  BSF    0A.3
....................    } 
....................     
....................    if(flagPlantaLigada){ 
0D45:  MOVF   59,F
0D46:  BTFSC  03.2
0D47:  GOTO   586
....................       if(flagTipoAcao==local){ 
0D48:  BSF    03.6
0D49:  DECFSZ 61,W
0D4A:  GOTO   568
....................          //MsgLocal 
....................          comando_lcd(0x80);  
0D4B:  MOVLW  80
0D4C:  MOVWF  62
0D4D:  BCF    0A.3
0D4E:  BCF    03.6
0D4F:  CALL   56A
0D50:  BSF    0A.3
....................          printf(escreve_lcd,"Planta ja ligada");  
0D51:  BSF    03.6
0D52:  CLRF   62
0D53:  MOVF   62,W
0D54:  BCF    0A.3
0D55:  BCF    03.6
0D56:  CALL   19A
0D57:  BSF    0A.3
0D58:  BSF    03.6
0D59:  INCF   62,F
0D5A:  MOVWF  77
0D5B:  BSF    03.5
0D5C:  MOVWF  10
0D5D:  BCF    0A.3
0D5E:  BCF    03.5
0D5F:  BCF    03.6
0D60:  CALL   58C
0D61:  BSF    0A.3
0D62:  MOVLW  10
0D63:  BSF    03.6
0D64:  SUBWF  62,W
0D65:  BTFSS  03.2
0D66:  GOTO   553
....................       }else{ 
0D67:  GOTO   584
....................          //MsgRemota 
....................          comando_lcd(0x80);  
0D68:  MOVLW  80
0D69:  MOVWF  62
0D6A:  BCF    0A.3
0D6B:  BCF    03.6
0D6C:  CALL   56A
0D6D:  BSF    0A.3
....................          printf(escreve_lcd,"Planta ja ligada");  
0D6E:  BSF    03.6
0D6F:  CLRF   62
0D70:  MOVF   62,W
0D71:  BCF    0A.3
0D72:  BCF    03.6
0D73:  CALL   19A
0D74:  BSF    0A.3
0D75:  BSF    03.6
0D76:  INCF   62,F
0D77:  MOVWF  77
0D78:  BSF    03.5
0D79:  MOVWF  10
0D7A:  BCF    0A.3
0D7B:  BCF    03.5
0D7C:  BCF    03.6
0D7D:  CALL   58C
0D7E:  BSF    0A.3
0D7F:  MOVLW  10
0D80:  BSF    03.6
0D81:  SUBWF  62,W
0D82:  BTFSS  03.2
0D83:  GOTO   570
....................       } 
....................    }else{ 
0D84:  GOTO   5C5
0D85:  BCF    03.6
....................       plantaligada(); 
0D86:  BSF    07.3
0D87:  MOVLW  01
0D88:  MOVWF  59
....................       if(flagTipoAcao==local){ 
0D89:  BSF    03.6
0D8A:  DECFSZ 61,W
0D8B:  GOTO   5A9
....................          //MsgLocal 
....................          comando_lcd(0x80);  
0D8C:  MOVLW  80
0D8D:  MOVWF  62
0D8E:  BCF    0A.3
0D8F:  BCF    03.6
0D90:  CALL   56A
0D91:  BSF    0A.3
....................          printf(escreve_lcd,"Acionam. local  "); 
0D92:  BSF    03.6
0D93:  CLRF   62
0D94:  MOVF   62,W
0D95:  BCF    0A.3
0D96:  BCF    03.6
0D97:  CALL   1AF
0D98:  BSF    0A.3
0D99:  BSF    03.6
0D9A:  INCF   62,F
0D9B:  MOVWF  77
0D9C:  BSF    03.5
0D9D:  MOVWF  10
0D9E:  BCF    0A.3
0D9F:  BCF    03.5
0DA0:  BCF    03.6
0DA1:  CALL   58C
0DA2:  BSF    0A.3
0DA3:  MOVLW  10
0DA4:  BSF    03.6
0DA5:  SUBWF  62,W
0DA6:  BTFSS  03.2
0DA7:  GOTO   594
....................       }else{ 
0DA8:  GOTO   5C5
....................          //MsgRemota 
....................          comando_lcd(0x80); 
0DA9:  MOVLW  80
0DAA:  MOVWF  62
0DAB:  BCF    0A.3
0DAC:  BCF    03.6
0DAD:  CALL   56A
0DAE:  BSF    0A.3
....................          printf(escreve_lcd,"Acionam. remoto ");              
0DAF:  BSF    03.6
0DB0:  CLRF   62
0DB1:  MOVF   62,W
0DB2:  BCF    0A.3
0DB3:  BCF    03.6
0DB4:  CALL   1C4
0DB5:  BSF    0A.3
0DB6:  BSF    03.6
0DB7:  INCF   62,F
0DB8:  MOVWF  77
0DB9:  BSF    03.5
0DBA:  MOVWF  10
0DBB:  BCF    0A.3
0DBC:  BCF    03.5
0DBD:  BCF    03.6
0DBE:  CALL   58C
0DBF:  BSF    0A.3
0DC0:  MOVLW  10
0DC1:  BSF    03.6
0DC2:  SUBWF  62,W
0DC3:  BTFSS  03.2
0DC4:  GOTO   5B1
....................       } 
....................    } 
....................    comando_lcd(0xC0);                                 
0DC5:  MOVLW  C0
0DC6:  MOVWF  62
0DC7:  BCF    0A.3
0DC8:  BCF    03.6
0DC9:  CALL   56A
0DCA:  BSF    0A.3
....................    printf(escreve_lcd,"Setpoint:%f   ", setpoint);         
0DCB:  BSF    03.6
0DCC:  CLRF   62
0DCD:  MOVF   62,W
0DCE:  BCF    0A.3
0DCF:  BCF    03.6
0DD0:  CALL   1D9
0DD1:  BSF    0A.3
0DD2:  BSF    03.6
0DD3:  INCF   62,F
0DD4:  MOVWF  77
0DD5:  BSF    03.5
0DD6:  MOVWF  10
0DD7:  BCF    0A.3
0DD8:  BCF    03.5
0DD9:  BCF    03.6
0DDA:  CALL   58C
0DDB:  BSF    0A.3
0DDC:  MOVLW  09
0DDD:  BSF    03.6
0DDE:  SUBWF  62,W
0DDF:  BTFSS  03.2
0DE0:  GOTO   5CD
0DE1:  MOVLW  89
0DE2:  MOVWF  04
0DE3:  BCF    03.6
0DE4:  MOVF   61,W
0DE5:  BSF    03.6
0DE6:  MOVWF  66
0DE7:  BCF    03.6
0DE8:  MOVF   60,W
0DE9:  BSF    03.6
0DEA:  MOVWF  65
0DEB:  BCF    03.6
0DEC:  MOVF   5F,W
0DED:  BSF    03.6
0DEE:  MOVWF  64
0DEF:  BCF    03.6
0DF0:  MOVF   5E,W
0DF1:  BSF    03.6
0DF2:  MOVWF  63
0DF3:  MOVLW  02
0DF4:  MOVWF  67
0DF5:  BCF    03.6
0DF6:  CALL   3DF
0DF7:  MOVLW  03
0DF8:  BSF    03.6
0DF9:  MOVWF  63
0DFA:  MOVLW  20
0DFB:  BSF    03.5
0DFC:  MOVWF  10
0DFD:  BCF    0A.3
0DFE:  BCF    03.5
0DFF:  BCF    03.6
0E00:  CALL   58C
0E01:  BSF    0A.3
0E02:  BSF    03.6
0E03:  DECFSZ 63,F
0E04:  GOTO   5FA
....................    
....................   conttime=8; 
0E05:  MOVLW  08
0E06:  MOVWF  7D
.................... }       
0E07:  BCF    03.6
0E08:  RETLW  00
....................  
....................  
.................... void desligaplanta(boolean flagTipoAcao){ 
....................    if(flagPlantaLigada){ 
0E09:  MOVF   59,F
0E0A:  BTFSC  03.2
0E0B:  GOTO   656
....................       plantadesligada(); 
0E0C:  BCF    07.3
0E0D:  BCF    07.0
0E0E:  BCF    07.5
0E0F:  BCF    06.6
0E10:  CLRF   15
0E11:  BCF    06.7
0E12:  BSF    07.1
0E13:  BCF    06.5
0E14:  CLRF   59
....................       limpa_lcd();   
0E15:  BCF    0A.3
0E16:  CALL   586
0E17:  BSF    0A.3
....................       if(flagTipoAcao==local){ 
0E18:  BSF    03.6
0E19:  DECFSZ 60,W
0E1A:  GOTO   638
....................          //MsgLocal 
....................          comando_lcd(0x80);  
0E1B:  MOVLW  80
0E1C:  MOVWF  62
0E1D:  BCF    0A.3
0E1E:  BCF    03.6
0E1F:  CALL   56A
0E20:  BSF    0A.3
....................          printf(escreve_lcd,"Desacion. local ");  
0E21:  BSF    03.6
0E22:  CLRF   61
0E23:  MOVF   61,W
0E24:  BCF    0A.3
0E25:  BCF    03.6
0E26:  CALL   1E9
0E27:  BSF    0A.3
0E28:  BSF    03.6
0E29:  INCF   61,F
0E2A:  MOVWF  77
0E2B:  BSF    03.5
0E2C:  MOVWF  10
0E2D:  BCF    0A.3
0E2E:  BCF    03.5
0E2F:  BCF    03.6
0E30:  CALL   58C
0E31:  BSF    0A.3
0E32:  MOVLW  10
0E33:  BSF    03.6
0E34:  SUBWF  61,W
0E35:  BTFSS  03.2
0E36:  GOTO   623
....................       }else{ 
0E37:  GOTO   654
....................          //MsgRemota 
....................          comando_lcd(0x80);  
0E38:  MOVLW  80
0E39:  MOVWF  62
0E3A:  BCF    0A.3
0E3B:  BCF    03.6
0E3C:  CALL   56A
0E3D:  BSF    0A.3
....................          printf(escreve_lcd,"Desacion. remoto");  
0E3E:  BSF    03.6
0E3F:  CLRF   61
0E40:  MOVF   61,W
0E41:  BCF    0A.3
0E42:  BCF    03.6
0E43:  CALL   1FE
0E44:  BSF    0A.3
0E45:  BSF    03.6
0E46:  INCF   61,F
0E47:  MOVWF  77
0E48:  BSF    03.5
0E49:  MOVWF  10
0E4A:  BCF    0A.3
0E4B:  BCF    03.5
0E4C:  BCF    03.6
0E4D:  CALL   58C
0E4E:  BSF    0A.3
0E4F:  MOVLW  10
0E50:  BSF    03.6
0E51:  SUBWF  61,W
0E52:  BTFSS  03.2
0E53:  GOTO   640
....................       } 
....................    }else{  
0E54:  GOTO   692
0E55:  BCF    03.6
....................       if(flagTipoAcao==local){ 
0E56:  BSF    03.6
0E57:  DECFSZ 60,W
0E58:  GOTO   676
....................          //MsgLocal 
....................          comando_lcd(0x80);  
0E59:  MOVLW  80
0E5A:  MOVWF  62
0E5B:  BCF    0A.3
0E5C:  BCF    03.6
0E5D:  CALL   56A
0E5E:  BSF    0A.3
....................          printf(escreve_lcd,"Planta ja deslig"); 
0E5F:  BSF    03.6
0E60:  CLRF   61
0E61:  MOVF   61,W
0E62:  BCF    0A.3
0E63:  BCF    03.6
0E64:  CALL   213
0E65:  BSF    0A.3
0E66:  BSF    03.6
0E67:  INCF   61,F
0E68:  MOVWF  77
0E69:  BSF    03.5
0E6A:  MOVWF  10
0E6B:  BCF    0A.3
0E6C:  BCF    03.5
0E6D:  BCF    03.6
0E6E:  CALL   58C
0E6F:  BSF    0A.3
0E70:  MOVLW  10
0E71:  BSF    03.6
0E72:  SUBWF  61,W
0E73:  BTFSS  03.2
0E74:  GOTO   661
....................       }else{ 
0E75:  GOTO   692
....................          //MsgRemota 
....................          comando_lcd(0x80); 
0E76:  MOVLW  80
0E77:  MOVWF  62
0E78:  BCF    0A.3
0E79:  BCF    03.6
0E7A:  CALL   56A
0E7B:  BSF    0A.3
....................          printf(escreve_lcd,"Planta ja deslig");       
0E7C:  BSF    03.6
0E7D:  CLRF   61
0E7E:  MOVF   61,W
0E7F:  BCF    0A.3
0E80:  BCF    03.6
0E81:  CALL   213
0E82:  BSF    0A.3
0E83:  BSF    03.6
0E84:  INCF   61,F
0E85:  MOVWF  77
0E86:  BSF    03.5
0E87:  MOVWF  10
0E88:  BCF    0A.3
0E89:  BCF    03.5
0E8A:  BCF    03.6
0E8B:  CALL   58C
0E8C:  BSF    0A.3
0E8D:  MOVLW  10
0E8E:  BSF    03.6
0E8F:  SUBWF  61,W
0E90:  BTFSS  03.2
0E91:  GOTO   67E
....................       } 
....................    }                                        
....................    comando_lcd(0xC0);                                  
0E92:  MOVLW  C0
0E93:  MOVWF  62
0E94:  BCF    0A.3
0E95:  BCF    03.6
0E96:  CALL   56A
0E97:  BSF    0A.3
....................    printf(escreve_lcd,"StandBy         ");   
0E98:  BSF    03.6
0E99:  CLRF   61
0E9A:  MOVF   61,W
0E9B:  BCF    0A.3
0E9C:  BCF    03.6
0E9D:  CALL   228
0E9E:  BSF    0A.3
0E9F:  BSF    03.6
0EA0:  INCF   61,F
0EA1:  MOVWF  77
0EA2:  BSF    03.5
0EA3:  MOVWF  10
0EA4:  BCF    0A.3
0EA5:  BCF    03.5
0EA6:  BCF    03.6
0EA7:  CALL   58C
0EA8:  BSF    0A.3
0EA9:  MOVLW  07
0EAA:  BSF    03.6
0EAB:  SUBWF  61,W
0EAC:  BTFSS  03.2
0EAD:  GOTO   69A
0EAE:  MOVLW  09
0EAF:  MOVWF  62
0EB0:  MOVLW  20
0EB1:  BSF    03.5
0EB2:  MOVWF  10
0EB3:  BCF    0A.3
0EB4:  BCF    03.5
0EB5:  BCF    03.6
0EB6:  CALL   58C
0EB7:  BSF    0A.3
0EB8:  BSF    03.6
0EB9:  DECFSZ 62,F
0EBA:  GOTO   6B0
....................    conttime=8; 
0EBB:  MOVLW  08
0EBC:  MOVWF  7D
.................... } 
0EBD:  BCF    03.6
0EBE:  RETLW  00
....................  
....................  
....................  
.................... void piscarele(void){    
....................    statusrele=!statusrele; 
....................    ledrele=statusrele; 
.................... } 
....................  
....................  
.................... /* void mostravalores(void){                             
....................    if(flagPlantaLigada){  
....................       printf("\n\r"); 
....................       printf("temp: %f\"",temp); 
....................       printf("\n\r"); 
....................       printf("setpoint: %f\"",setpoint); 
....................       printf("\n\r"); 
....................       printf("tempgap: %f\"",tempgap); 
....................       printf("\n\r"); 
....................       printf("tempalerta: %f\"",tempalerta); 
....................       printf("\n\r"); 
....................       printf("setpointgap: %f\"",setpointgap); 
....................       printf("\n\r"); 
....................    } 
.................... } 
.................... */ 
....................  
.................... #include "script_sms.h"            // logica de tratamento de mensagens SMS 
....................  // script_sms.h 
....................   
.................... void checaSMS(void){ 
....................   
.................... switch(tipoComando){ 
*
1000:  MOVF   36,W
1001:  XORLW  01
1002:  BTFSC  03.2
1003:  GOTO   00B
1004:  XORLW  03
1005:  BTFSC  03.2
1006:  GOTO   00D
1007:  XORLW  01
1008:  BTFSC  03.2
1009:  GOTO   055
100A:  GOTO   5C4
....................       case 1: // Caso msg identificada como ATOK 
....................          tipoComando=0;      
100B:  CLRF   36
....................       break; 
100C:  GOTO   5C4
....................       case 2: // Caso msg identificada como CMTI 
....................          tipoComando=0; 
100D:  CLRF   36
....................          limpa_lcd(); 
100E:  BCF    0A.4
100F:  CALL   586
1010:  BSF    0A.4
....................          comando_lcd(0x80); 
1011:  MOVLW  80
1012:  BSF    03.6
1013:  MOVWF  62
1014:  BCF    0A.4
1015:  BCF    03.6
1016:  CALL   56A
1017:  BSF    0A.4
....................          printf(escreve_lcd, "SMS Recebido"); 
1018:  BSF    03.6
1019:  CLRF   60
101A:  MOVF   60,W
101B:  BCF    0A.4
101C:  BCF    03.6
101D:  CALL   234
101E:  BSF    0A.4
101F:  BSF    03.6
1020:  INCF   60,F
1021:  MOVWF  77
1022:  BSF    03.5
1023:  MOVWF  10
1024:  BCF    0A.4
1025:  BCF    03.5
1026:  BCF    03.6
1027:  CALL   58C
1028:  BSF    0A.4
1029:  MOVLW  0C
102A:  BSF    03.6
102B:  SUBWF  60,W
102C:  BTFSS  03.2
102D:  GOTO   01A
....................          printf("AT+CMGR=%i\n\r", cmtiIndex); 
102E:  CLRF   60
102F:  MOVF   60,W
1030:  BCF    0A.4
1031:  BCF    03.6
1032:  CALL   245
1033:  BSF    0A.4
1034:  BSF    03.6
1035:  INCF   60,F
1036:  MOVWF  77
1037:  BCF    03.6
1038:  BTFSS  0C.4
1039:  GOTO   038
103A:  MOVWF  19
103B:  MOVLW  08
103C:  BSF    03.6
103D:  SUBWF  60,W
103E:  BTFSS  03.2
103F:  GOTO   02F
1040:  BCF    03.6
1041:  MOVF   57,W
1042:  BSF    03.6
1043:  MOVWF  61
1044:  MOVLW  1F
1045:  MOVWF  62
1046:  BCF    0A.4
1047:  BCF    03.6
1048:  CALL   5FD
1049:  BSF    0A.4
104A:  MOVLW  0A
104B:  BTFSS  0C.4
104C:  GOTO   04B
104D:  MOVWF  19
104E:  MOVLW  0D
104F:  BTFSS  0C.4
1050:  GOTO   04F
1051:  MOVWF  19
....................          conttime=4; 
1052:  MOVLW  04
1053:  MOVWF  7D
....................       break; 
1054:  GOTO   5C4
....................       case 3: // Caso msg identificada como CMGR 
....................          tipoComando=0; 
1055:  CLRF   36
....................          limpa_lcd(); 
1056:  BCF    0A.4
1057:  CALL   586
1058:  BSF    0A.4
....................          comando_lcd(0x80); 
1059:  MOVLW  80
105A:  BSF    03.6
105B:  MOVWF  62
105C:  BCF    0A.4
105D:  BCF    03.6
105E:  CALL   56A
105F:  BSF    0A.4
....................          printf(escreve_lcd, "+CMGR"); 
1060:  BSF    03.6
1061:  CLRF   60
1062:  MOVF   60,W
1063:  BCF    0A.4
1064:  BCF    03.6
1065:  CALL   256
1066:  BSF    0A.4
1067:  BSF    03.6
1068:  INCF   60,F
1069:  MOVWF  77
106A:  BSF    03.5
106B:  MOVWF  10
106C:  BCF    0A.4
106D:  BCF    03.5
106E:  BCF    03.6
106F:  CALL   58C
1070:  BSF    0A.4
1071:  MOVLW  05
1072:  BSF    03.6
1073:  SUBWF  60,W
1074:  BTFSS  03.2
1075:  GOTO   062
....................          comando_lcd(0xC0);   
1076:  MOVLW  C0
1077:  MOVWF  62
1078:  BCF    0A.4
1079:  BCF    03.6
107A:  CALL   56A
107B:  BSF    0A.4
....................          while(flagSMS&&contTimeOut!=0){ 
107C:  MOVF   58,F
107D:  BTFSC  03.2
107E:  GOTO   086
107F:  MOVF   32,F
1080:  BTFSC  03.2
1081:  GOTO   086
....................             contTimeOut--; 
1082:  DECF   32,F
....................             conttime=4; 
1083:  MOVLW  04
1084:  MOVWF  7D
....................          } 
1085:  GOTO   07C
....................          printf(escreve_lcd, "SMS: %s",sms);      //!-Rotina de escrita e tratamento de SMS 
1086:  BSF    03.6
1087:  CLRF   60
1088:  MOVF   60,W
1089:  BCF    0A.4
108A:  BCF    03.6
108B:  CALL   260
108C:  BSF    0A.4
108D:  BSF    03.6
108E:  INCF   60,F
108F:  MOVWF  77
1090:  BSF    03.5
1091:  MOVWF  10
1092:  BCF    0A.4
1093:  BCF    03.5
1094:  BCF    03.6
1095:  CALL   58C
1096:  BSF    0A.4
1097:  MOVLW  05
1098:  BSF    03.6
1099:  SUBWF  60,W
109A:  BTFSS  03.2
109B:  GOTO   088
109C:  MOVLW  37
109D:  MOVWF  04
109E:  BCF    03.7
109F:  MOVLW  00
10A0:  IORWF  00,W
10A1:  BTFSC  03.2
10A2:  GOTO   0B9
10A3:  CLRF   62
10A4:  MOVF   04,W
10A5:  MOVWF  61
10A6:  BCF    62.0
10A7:  BTFSC  03.7
10A8:  BSF    62.0
10A9:  MOVF   00,W
10AA:  BSF    03.5
10AB:  MOVWF  10
10AC:  BCF    0A.4
10AD:  BCF    03.5
10AE:  BCF    03.6
10AF:  CALL   58C
10B0:  BSF    0A.4
10B1:  BSF    03.6
10B2:  MOVF   61,W
10B3:  MOVWF  04
10B4:  BCF    03.7
10B5:  BTFSC  62.0
10B6:  BSF    03.7
10B7:  INCF   04,F
10B8:  GOTO   09F
....................          //delay_ms(50); 
....................          conttime=6;   
10B9:  MOVLW  06
10BA:  MOVWF  7D
....................          printf("%s",sms);                        //Imprime SMS recebida para serial 
10BB:  MOVLW  37
10BC:  MOVWF  04
10BD:  BCF    03.7
10BE:  MOVLW  00
10BF:  IORWF  00,W
10C0:  BTFSC  03.2
10C1:  GOTO   0CA
10C2:  MOVF   00,W
10C3:  BCF    03.6
10C4:  BTFSS  0C.4
10C5:  GOTO   0C4
10C6:  MOVWF  19
10C7:  INCF   04,F
10C8:  BSF    03.6
10C9:  GOTO   0BE
....................          printf("\n\r"); 
10CA:  MOVLW  0A
10CB:  BCF    03.6
10CC:  BTFSS  0C.4
10CD:  GOTO   0CC
10CE:  MOVWF  19
10CF:  MOVLW  0D
10D0:  BTFSS  0C.4
10D1:  GOTO   0D0
10D2:  MOVWF  19
....................          printf("AT+CMGD=%i\n\r", cmtiIndex); 
10D3:  BSF    03.6
10D4:  CLRF   60
10D5:  MOVF   60,W
10D6:  BCF    0A.4
10D7:  BCF    03.6
10D8:  CALL   26C
10D9:  BSF    0A.4
10DA:  BSF    03.6
10DB:  INCF   60,F
10DC:  MOVWF  77
10DD:  BCF    03.6
10DE:  BTFSS  0C.4
10DF:  GOTO   0DE
10E0:  MOVWF  19
10E1:  MOVLW  08
10E2:  BSF    03.6
10E3:  SUBWF  60,W
10E4:  BTFSS  03.2
10E5:  GOTO   0D5
10E6:  BCF    03.6
10E7:  MOVF   57,W
10E8:  BSF    03.6
10E9:  MOVWF  61
10EA:  MOVLW  1F
10EB:  MOVWF  62
10EC:  BCF    0A.4
10ED:  BCF    03.6
10EE:  CALL   5FD
10EF:  BSF    0A.4
10F0:  MOVLW  0A
10F1:  BTFSS  0C.4
10F2:  GOTO   0F1
10F3:  MOVWF  19
10F4:  MOVLW  0D
10F5:  BTFSS  0C.4
10F6:  GOTO   0F5
10F7:  MOVWF  19
....................          printf("AT+CMGF=1\n\r"); 
10F8:  BSF    03.6
10F9:  CLRF   60
10FA:  MOVF   60,W
10FB:  BCF    0A.4
10FC:  BCF    03.6
10FD:  CALL   27D
10FE:  BSF    0A.4
10FF:  BSF    03.6
1100:  INCF   60,F
1101:  MOVWF  77
1102:  BCF    03.6
1103:  BTFSS  0C.4
1104:  GOTO   103
1105:  MOVWF  19
1106:  MOVLW  0B
1107:  BSF    03.6
1108:  SUBWF  60,W
1109:  BTFSS  03.2
110A:  GOTO   0FA
....................         
....................         
....................          if(strcmp(sms, smsplantaon)==0){         
110B:  CLRF   61
110C:  MOVLW  37
110D:  MOVWF  60
110E:  MOVLW  01
110F:  MOVWF  63
1110:  MOVLW  1B
1111:  MOVWF  62
1112:  BCF    0A.4
1113:  BCF    03.6
1114:  CALL   672
1115:  BSF    0A.4
1116:  MOVF   78,F
1117:  BTFSS  03.2
1118:  GOTO   122
....................            ligaplanta(naoalterasetpoint, remoto); //acao executada 
1119:  BSF    03.6
111A:  CLRF   60
111B:  CLRF   61
111C:  BCF    0A.4
111D:  BSF    0A.3
111E:  BCF    03.6
111F:  CALL   4F7
1120:  BSF    0A.4
1121:  BCF    0A.3
1122:  CLRF   28
1123:  BTFSC  0B.7
1124:  BSF    28.7
1125:  BCF    0B.7
....................          } 
....................           
....................          if(strncmp(sms, smsplantasp,8)==0){          
1126:  BSF    03.5
1127:  BSF    03.6
1128:  CLRF   29
1129:  MOVLW  37
112A:  MOVWF  28
112B:  MOVLW  01
112C:  MOVWF  2B
112D:  MOVLW  24
112E:  MOVWF  2A
112F:  MOVLW  08
1130:  MOVWF  2C
1131:  BCF    0A.4
1132:  BCF    03.5
1133:  BCF    03.6
1134:  CALL   2D8
1135:  BSF    0A.4
1136:  BTFSC  28.7
1137:  BSF    0B.7
1138:  MOVF   78,F
1139:  BTFSS  03.2
113A:  GOTO   145
....................            ligaplanta(alterasetpoint, remoto); //acao executada 
113B:  MOVLW  01
113C:  BSF    03.6
113D:  MOVWF  60
113E:  CLRF   61
113F:  BCF    0A.4
1140:  BSF    0A.3
1141:  BCF    03.6
1142:  CALL   4F7
1143:  BSF    0A.4
1144:  BCF    0A.3
....................          } 
....................           
....................          if(strcmp(sms, smsplantaoff)==0){           
1145:  BSF    03.6
1146:  CLRF   61
1147:  MOVLW  37
1148:  MOVWF  60
1149:  MOVLW  01
114A:  MOVWF  63
114B:  MOVLW  2D
114C:  MOVWF  62
114D:  BCF    0A.4
114E:  BCF    03.6
114F:  CALL   672
1150:  BSF    0A.4
1151:  MOVF   78,F
1152:  BTFSS  03.2
1153:  GOTO   15C
....................            desligaplanta(remoto); //acao executada 
1154:  BSF    03.6
1155:  CLRF   60
1156:  BCF    0A.4
1157:  BSF    0A.3
1158:  BCF    03.6
1159:  CALL   609
115A:  BSF    0A.4
115B:  BCF    0A.3
....................          } 
....................           
....................          if(strcmp(sms, smstemp)==0){          
115C:  BSF    03.6
115D:  CLRF   61
115E:  MOVLW  37
115F:  MOVWF  60
1160:  MOVLW  01
1161:  MOVWF  63
1162:  MOVLW  37
1163:  MOVWF  62
1164:  BCF    0A.4
1165:  BCF    03.6
1166:  CALL   672
1167:  BSF    0A.4
1168:  MOVF   78,F
1169:  BTFSS  03.2
116A:  GOTO   31E
....................            enviatemp(); //acao executada 
....................          } 
....................           
....................          if(strncmp(sms, smstempgap,8)==0){ 
*
1322:  BSF    03.5
1323:  BSF    03.6
1324:  CLRF   29
1325:  MOVLW  37
1326:  MOVWF  28
1327:  MOVLW  01
1328:  MOVWF  2B
1329:  MOVLW  48
132A:  MOVWF  2A
132B:  MOVLW  08
132C:  MOVWF  2C
132D:  BCF    0A.4
132E:  BCF    03.5
132F:  BCF    03.6
1330:  CALL   2D8
1331:  BSF    0A.4
1332:  BTFSC  28.7
1333:  BSF    0B.7
1334:  MOVF   78,F
1335:  BTFSS  03.2
1336:  GOTO   45A
....................            tempgaprecebido(); //acao executada 
....................          } 
....................           
....................          if(strncmp(sms, smstempalerta,8)==0){  
*
145E:  BSF    03.5
145F:  BSF    03.6
1460:  CLRF   29
1461:  MOVLW  37
1462:  MOVWF  28
1463:  MOVLW  01
1464:  MOVWF  2B
1465:  MOVLW  3F
1466:  MOVWF  2A
1467:  MOVLW  08
1468:  MOVWF  2C
1469:  BCF    0A.4
146A:  BCF    03.5
146B:  BCF    03.6
146C:  CALL   2D8
146D:  BSF    0A.4
146E:  BTFSC  28.7
146F:  BSF    0B.7
1470:  MOVF   78,F
1471:  BTFSS  03.2
1472:  GOTO   5A1
....................            tempalertarecebido(); //acao executada 
....................          } 
....................           
....................          if(strcmp(sms, smsreleon)==0){          
*
15A1:  BSF    03.6
15A2:  CLRF   61
15A3:  MOVLW  37
15A4:  MOVWF  60
15A5:  MOVLW  01
15A6:  MOVWF  63
15A7:  MOVLW  51
15A8:  MOVWF  62
15A9:  BCF    0A.4
15AA:  BCF    03.6
15AB:  CALL   672
15AC:  BSF    0A.4
15AD:  MOVF   78,F
15AE:  BTFSS  03.2
15AF:  GOTO   5B2
....................            releligado(); //acao executada 
15B0:  BSF    07.0
15B1:  BSF    07.4
....................          } 
....................          if(strcmp(sms, smsreleoff)==0){          
15B2:  BSF    03.6
15B3:  CLRF   61
15B4:  MOVLW  37
15B5:  MOVWF  60
15B6:  MOVLW  01
15B7:  MOVWF  63
15B8:  MOVLW  58
15B9:  MOVWF  62
15BA:  BCF    0A.4
15BB:  BCF    03.6
15BC:  CALL   672
15BD:  BSF    0A.4
15BE:  MOVF   78,F
15BF:  BTFSS  03.2
15C0:  GOTO   5C3
....................            reledesligado(); //acao executada 
15C1:  BCF    07.0
15C2:  BCF    07.4
....................          } 
....................           
....................           
.................... // DEPRECATED ACTIONS          
....................           
.................... //         if(strcmp(sms, smsligaralerta)==0){       
.................... //           buzzerligado();  //acao executada 
.................... //         } 
....................          
.................... //         if(strcmp(sms, smsdesligaralerta)==0){  
.................... //           buzzerdesligado(); //acao executada 
.................... //         } 
....................           
.................... //         if(strcmp(sms, smsreleon)==0){        
.................... //           releligado(); //acao executada 
.................... //         } 
....................              
.................... //         if(strcmp(sms, smsreleoff)==0){             
.................... //           reledesligado(); //acao executada 
.................... //         } 
....................  
....................  
....................      break; 
15C3:  GOTO   5C4
....................      default:   
....................    } 
.................... } 
15C4:  BSF    0A.3
15C5:  BSF    0A.4
15C6:  GOTO   5D3 (RETURN)
....................  
.................... #include "script_temp.h"            // logica de tratamento de temperatura 
.................... // script_temp.h 
....................  
.................... void checaTemperatura(void){ 
....................     
....................    if(flagPlantaLigada){ 
*
1800:  MOVF   59,F
1801:  BTFSC  03.2
1802:  GOTO   415
....................       set_adc_channel(2); 
1803:  MOVLW  10
1804:  MOVWF  78
1805:  MOVF   1F,W
1806:  ANDLW  C7
1807:  IORWF  78,W
1808:  MOVWF  1F
....................       delay_us(20);  
1809:  MOVLW  0D
180A:  MOVWF  77
180B:  DECFSZ 77,F
180C:  GOTO   00B
....................       conttemp=0; 
180D:  CLRF   76
....................       temp=0; 
180E:  CLRF   69
180F:  CLRF   68
1810:  CLRF   67
1811:  CLRF   66
....................        
....................       for(;conttemp<10;conttemp++){       // media de temperatura em 10 leituras para maior estabilidade 
1812:  MOVF   76,W
1813:  SUBLW  09
1814:  BTFSS  03.0
1815:  GOTO   160
....................          tensao=read_adc(); 
1816:  BSF    1F.2
1817:  BTFSC  1F.2
1818:  GOTO   017
1819:  MOVF   1E,W
181A:  MOVWF  7A
181B:  BSF    03.5
181C:  MOVF   1E,W
181D:  BSF    03.6
181E:  MOVWF  14
181F:  MOVF   7A,W
1820:  MOVWF  15
1821:  BCF    0A.4
1822:  BCF    0A.3
1823:  BCF    03.5
1824:  BCF    03.6
1825:  CALL   732
1826:  BSF    0A.4
1827:  BSF    0A.3
1828:  MOVF   7A,W
1829:  MOVWF  5D
182A:  MOVF   79,W
182B:  MOVWF  5C
182C:  MOVF   78,W
182D:  MOVWF  5B
182E:  MOVF   77,W
182F:  MOVWF  5A
....................          tensao=tensao*5; 
1830:  MOVF   5D,W
1831:  BSF    03.5
1832:  BSF    03.6
1833:  MOVWF  13
1834:  BCF    03.5
1835:  BCF    03.6
1836:  MOVF   5C,W
1837:  BSF    03.5
1838:  BSF    03.6
1839:  MOVWF  12
183A:  BCF    03.5
183B:  BCF    03.6
183C:  MOVF   5B,W
183D:  BSF    03.5
183E:  BSF    03.6
183F:  MOVWF  11
1840:  BCF    03.5
1841:  BCF    03.6
1842:  MOVF   5A,W
1843:  BSF    03.5
1844:  BSF    03.6
1845:  MOVWF  10
1846:  CLRF   17
1847:  CLRF   16
1848:  MOVLW  20
1849:  MOVWF  15
184A:  MOVLW  81
184B:  MOVWF  14
184C:  BCF    0A.4
184D:  BCF    0A.3
184E:  BCF    03.5
184F:  BCF    03.6
1850:  CALL   6B9
1851:  BSF    0A.4
1852:  BSF    0A.3
1853:  MOVF   7A,W
1854:  MOVWF  5D
1855:  MOVF   79,W
1856:  MOVWF  5C
1857:  MOVF   78,W
1858:  MOVWF  5B
1859:  MOVF   77,W
185A:  MOVWF  5A
....................          tensao=tensao/1023; 
185B:  MOVF   5D,W
185C:  BSF    03.5
185D:  BSF    03.6
185E:  MOVWF  14
185F:  BCF    03.5
1860:  BCF    03.6
1861:  MOVF   5C,W
1862:  BSF    03.5
1863:  BSF    03.6
1864:  MOVWF  13
1865:  BCF    03.5
1866:  BCF    03.6
1867:  MOVF   5B,W
1868:  BSF    03.5
1869:  BSF    03.6
186A:  MOVWF  12
186B:  BCF    03.5
186C:  BCF    03.6
186D:  MOVF   5A,W
186E:  BSF    03.5
186F:  BSF    03.6
1870:  MOVWF  11
1871:  CLRF   18
1872:  MOVLW  C0
1873:  MOVWF  17
1874:  MOVLW  7F
1875:  MOVWF  16
1876:  MOVLW  88
1877:  MOVWF  15
1878:  BCF    0A.4
1879:  BCF    03.5
187A:  BCF    03.6
187B:  CALL   14A
187C:  BSF    0A.4
187D:  MOVF   7A,W
187E:  MOVWF  5D
187F:  MOVF   79,W
1880:  MOVWF  5C
1881:  MOVF   78,W
1882:  MOVWF  5B
1883:  MOVF   77,W
1884:  MOVWF  5A
....................           
....................          // Escolhendo modo de temperatura pelo modo de operação do firmware configurado em variaveis 
....................          if(firmwaremode==0){ 
1885:  MOVF   31,F
1886:  BTFSS  03.2
1887:  GOTO   10F
....................            temp=(90*tensao);  // Temperatura para operação com protótipo e sensor de temperatura PT-100 
1888:  BSF    03.5
1889:  BSF    03.6
188A:  CLRF   13
188B:  CLRF   12
188C:  MOVLW  34
188D:  MOVWF  11
188E:  MOVLW  85
188F:  MOVWF  10
1890:  BCF    03.5
1891:  BCF    03.6
1892:  MOVF   5D,W
1893:  BSF    03.5
1894:  BSF    03.6
1895:  MOVWF  17
1896:  BCF    03.5
1897:  BCF    03.6
1898:  MOVF   5C,W
1899:  BSF    03.5
189A:  BSF    03.6
189B:  MOVWF  16
189C:  BCF    03.5
189D:  BCF    03.6
189E:  MOVF   5B,W
189F:  BSF    03.5
18A0:  BSF    03.6
18A1:  MOVWF  15
18A2:  BCF    03.5
18A3:  BCF    03.6
18A4:  MOVF   5A,W
18A5:  BSF    03.5
18A6:  BSF    03.6
18A7:  MOVWF  14
18A8:  BCF    0A.4
18A9:  BCF    0A.3
18AA:  BCF    03.5
18AB:  BCF    03.6
18AC:  CALL   6B9
18AD:  BSF    0A.4
18AE:  BSF    0A.3
18AF:  MOVF   7A,W
18B0:  MOVWF  69
18B1:  MOVF   79,W
18B2:  MOVWF  68
18B3:  MOVF   78,W
18B4:  MOVWF  67
18B5:  MOVF   77,W
18B6:  MOVWF  66
....................            temp=temp-78.39; 
18B7:  BSF    03.1
18B8:  MOVF   69,W
18B9:  BSF    03.5
18BA:  BSF    03.6
18BB:  MOVWF  1B
18BC:  BCF    03.5
18BD:  BCF    03.6
18BE:  MOVF   68,W
18BF:  BSF    03.5
18C0:  BSF    03.6
18C1:  MOVWF  1A
18C2:  BCF    03.5
18C3:  BCF    03.6
18C4:  MOVF   67,W
18C5:  BSF    03.5
18C6:  BSF    03.6
18C7:  MOVWF  19
18C8:  BCF    03.5
18C9:  BCF    03.6
18CA:  MOVF   66,W
18CB:  BSF    03.5
18CC:  BSF    03.6
18CD:  MOVWF  18
18CE:  MOVLW  AE
18CF:  MOVWF  1F
18D0:  MOVLW  C7
18D1:  MOVWF  1E
18D2:  MOVLW  1C
18D3:  MOVWF  1D
18D4:  MOVLW  85
18D5:  MOVWF  1C
18D6:  BCF    0A.4
18D7:  BCF    03.5
18D8:  BCF    03.6
18D9:  CALL   000
18DA:  BSF    0A.4
18DB:  MOVF   7A,W
18DC:  MOVWF  69
18DD:  MOVF   79,W
18DE:  MOVWF  68
18DF:  MOVF   78,W
18E0:  MOVWF  67
18E1:  MOVF   77,W
18E2:  MOVWF  66
....................            temp=temp/3.049; 
18E3:  MOVF   69,W
18E4:  BSF    03.5
18E5:  BSF    03.6
18E6:  MOVWF  14
18E7:  BCF    03.5
18E8:  BCF    03.6
18E9:  MOVF   68,W
18EA:  BSF    03.5
18EB:  BSF    03.6
18EC:  MOVWF  13
18ED:  BCF    03.5
18EE:  BCF    03.6
18EF:  MOVF   67,W
18F0:  BSF    03.5
18F1:  BSF    03.6
18F2:  MOVWF  12
18F3:  BCF    03.5
18F4:  BCF    03.6
18F5:  MOVF   66,W
18F6:  BSF    03.5
18F7:  BSF    03.6
18F8:  MOVWF  11
18F9:  MOVLW  D1
18FA:  MOVWF  18
18FB:  MOVLW  22
18FC:  MOVWF  17
18FD:  MOVLW  43
18FE:  MOVWF  16
18FF:  MOVLW  80
1900:  MOVWF  15
1901:  BCF    0A.4
1902:  BCF    03.5
1903:  BCF    03.6
1904:  CALL   14A
1905:  BSF    0A.4
1906:  MOVF   7A,W
1907:  MOVWF  69
1908:  MOVF   79,W
1909:  MOVWF  68
190A:  MOVF   78,W
190B:  MOVWF  67
190C:  MOVF   77,W
190D:  MOVWF  66
....................          }else{ 
190E:  GOTO   15E
....................            temp+=tensao*10;   // Temperatura para operação com sistema de Temperatura do Kit de Desenvolvimento  
190F:  MOVF   5D,W
1910:  BSF    03.5
1911:  BSF    03.6
1912:  MOVWF  13
1913:  BCF    03.5
1914:  BCF    03.6
1915:  MOVF   5C,W
1916:  BSF    03.5
1917:  BSF    03.6
1918:  MOVWF  12
1919:  BCF    03.5
191A:  BCF    03.6
191B:  MOVF   5B,W
191C:  BSF    03.5
191D:  BSF    03.6
191E:  MOVWF  11
191F:  BCF    03.5
1920:  BCF    03.6
1921:  MOVF   5A,W
1922:  BSF    03.5
1923:  BSF    03.6
1924:  MOVWF  10
1925:  CLRF   17
1926:  CLRF   16
1927:  MOVLW  20
1928:  MOVWF  15
1929:  MOVLW  82
192A:  MOVWF  14
192B:  BCF    0A.4
192C:  BCF    0A.3
192D:  BCF    03.5
192E:  BCF    03.6
192F:  CALL   6B9
1930:  BSF    0A.4
1931:  BSF    0A.3
1932:  BCF    03.1
1933:  MOVF   69,W
1934:  BSF    03.5
1935:  BSF    03.6
1936:  MOVWF  1B
1937:  BCF    03.5
1938:  BCF    03.6
1939:  MOVF   68,W
193A:  BSF    03.5
193B:  BSF    03.6
193C:  MOVWF  1A
193D:  BCF    03.5
193E:  BCF    03.6
193F:  MOVF   67,W
1940:  BSF    03.5
1941:  BSF    03.6
1942:  MOVWF  19
1943:  BCF    03.5
1944:  BCF    03.6
1945:  MOVF   66,W
1946:  BSF    03.5
1947:  BSF    03.6
1948:  MOVWF  18
1949:  MOVF   7A,W
194A:  MOVWF  1F
194B:  MOVF   79,W
194C:  MOVWF  1E
194D:  MOVF   78,W
194E:  MOVWF  1D
194F:  MOVF   77,W
1950:  MOVWF  1C
1951:  BCF    0A.4
1952:  BCF    03.5
1953:  BCF    03.6
1954:  CALL   000
1955:  BSF    0A.4
1956:  MOVF   7A,W
1957:  MOVWF  69
1958:  MOVF   79,W
1959:  MOVWF  68
195A:  MOVF   78,W
195B:  MOVWF  67
195C:  MOVF   77,W
195D:  MOVWF  66
....................          } 
....................       } 
195E:  INCF   76,F
195F:  GOTO   012
....................     
....................       if(conttime==0){ 
1960:  MOVF   7D,F
1961:  BTFSS  03.2
1962:  GOTO   1E0
....................          limpa_lcd();                                    // Função Limpa conteúdo do LCD 
1963:  BCF    0A.4
1964:  BCF    0A.3
1965:  CALL   586
1966:  BSF    0A.4
1967:  BSF    0A.3
....................          comando_lcd(0x80);                              // Escolhe linha 1 do LCD 
1968:  MOVLW  80
1969:  BSF    03.6
196A:  MOVWF  62
196B:  BCF    0A.4
196C:  BCF    0A.3
196D:  BCF    03.6
196E:  CALL   56A
196F:  BSF    0A.4
1970:  BSF    0A.3
....................          printf(escreve_lcd, "Temp: %f",temp);           // Envia valor da temperatura para LCD 
1971:  BSF    03.6
1972:  CLRF   60
1973:  MOVF   60,W
1974:  BCF    0A.4
1975:  BCF    0A.3
1976:  BCF    03.6
1977:  CALL   167
1978:  BSF    0A.4
1979:  BSF    0A.3
197A:  BSF    03.6
197B:  INCF   60,F
197C:  MOVWF  77
197D:  BSF    03.5
197E:  MOVWF  10
197F:  BCF    0A.4
1980:  BCF    0A.3
1981:  BCF    03.5
1982:  BCF    03.6
1983:  CALL   58C
1984:  BSF    0A.4
1985:  BSF    0A.3
1986:  MOVLW  06
1987:  BSF    03.6
1988:  SUBWF  60,W
1989:  BTFSS  03.2
198A:  GOTO   173
198B:  MOVLW  89
198C:  MOVWF  04
198D:  BCF    03.6
198E:  MOVF   69,W
198F:  BSF    03.6
1990:  MOVWF  66
1991:  BCF    03.6
1992:  MOVF   68,W
1993:  BSF    03.6
1994:  MOVWF  65
1995:  BCF    03.6
1996:  MOVF   67,W
1997:  BSF    03.6
1998:  MOVWF  64
1999:  BCF    03.6
199A:  MOVF   66,W
199B:  BSF    03.6
199C:  MOVWF  63
199D:  MOVLW  02
199E:  MOVWF  67
199F:  BCF    0A.4
19A0:  BCF    03.6
19A1:  CALL   3DF
19A2:  BSF    0A.4
....................          comando_lcd(0xC0);                              // Escolhe linha 2 do LCD 
19A3:  MOVLW  C0
19A4:  BSF    03.6
19A5:  MOVWF  62
19A6:  BCF    0A.4
19A7:  BCF    0A.3
19A8:  BCF    03.6
19A9:  CALL   56A
19AA:  BSF    0A.4
19AB:  BSF    0A.3
....................          printf(escreve_lcd, "Setpoint: %f",setpoint);   // Envia valor de setpoint para LCD 
19AC:  BSF    03.6
19AD:  CLRF   60
19AE:  MOVF   60,W
19AF:  BCF    0A.4
19B0:  BCF    0A.3
19B1:  BCF    03.6
19B2:  CALL   28D
19B3:  BSF    0A.4
19B4:  BSF    0A.3
19B5:  BSF    03.6
19B6:  INCF   60,F
19B7:  MOVWF  77
19B8:  BSF    03.5
19B9:  MOVWF  10
19BA:  BCF    0A.4
19BB:  BCF    0A.3
19BC:  BCF    03.5
19BD:  BCF    03.6
19BE:  CALL   58C
19BF:  BSF    0A.4
19C0:  BSF    0A.3
19C1:  MOVLW  0A
19C2:  BSF    03.6
19C3:  SUBWF  60,W
19C4:  BTFSS  03.2
19C5:  GOTO   1AE
19C6:  MOVLW  89
19C7:  MOVWF  04
19C8:  BCF    03.6
19C9:  MOVF   61,W
19CA:  BSF    03.6
19CB:  MOVWF  66
19CC:  BCF    03.6
19CD:  MOVF   60,W
19CE:  BSF    03.6
19CF:  MOVWF  65
19D0:  BCF    03.6
19D1:  MOVF   5F,W
19D2:  BSF    03.6
19D3:  MOVWF  64
19D4:  BCF    03.6
19D5:  MOVF   5E,W
19D6:  BSF    03.6
19D7:  MOVWF  63
19D8:  MOVLW  02
19D9:  MOVWF  67
19DA:  BCF    0A.4
19DB:  BCF    03.6
19DC:  CALL   3DF
19DD:  BSF    0A.4
....................          conttime=8;                                     // A cada unidade incrementada o valor de tempo será de 250ms 
19DE:  MOVLW  08
19DF:  MOVWF  7D
....................       } 
....................        
....................        
....................        if(temp>(setpoint+setpointgap)){ 
19E0:  BCF    03.1
19E1:  MOVF   61,W
19E2:  BSF    03.5
19E3:  BSF    03.6
19E4:  MOVWF  1B
19E5:  BCF    03.5
19E6:  BCF    03.6
19E7:  MOVF   60,W
19E8:  BSF    03.5
19E9:  BSF    03.6
19EA:  MOVWF  1A
19EB:  BCF    03.5
19EC:  BCF    03.6
19ED:  MOVF   5F,W
19EE:  BSF    03.5
19EF:  BSF    03.6
19F0:  MOVWF  19
19F1:  BCF    03.5
19F2:  BCF    03.6
19F3:  MOVF   5E,W
19F4:  BSF    03.5
19F5:  BSF    03.6
19F6:  MOVWF  18
19F7:  BCF    03.5
19F8:  BCF    03.6
19F9:  MOVF   65,W
19FA:  BSF    03.5
19FB:  BSF    03.6
19FC:  MOVWF  1F
19FD:  BCF    03.5
19FE:  BCF    03.6
19FF:  MOVF   64,W
1A00:  BSF    03.5
1A01:  BSF    03.6
1A02:  MOVWF  1E
1A03:  BCF    03.5
1A04:  BCF    03.6
1A05:  MOVF   63,W
1A06:  BSF    03.5
1A07:  BSF    03.6
1A08:  MOVWF  1D
1A09:  BCF    03.5
1A0A:  BCF    03.6
1A0B:  MOVF   62,W
1A0C:  BSF    03.5
1A0D:  BSF    03.6
1A0E:  MOVWF  1C
1A0F:  BCF    0A.4
1A10:  BCF    03.5
1A11:  BCF    03.6
1A12:  CALL   000
1A13:  BSF    0A.4
1A14:  MOVF   7A,W
1A15:  BSF    03.6
1A16:  MOVWF  67
1A17:  MOVF   79,W
1A18:  MOVWF  66
1A19:  MOVF   78,W
1A1A:  MOVWF  65
1A1B:  MOVF   77,W
1A1C:  MOVWF  64
1A1D:  BCF    03.6
1A1E:  MOVF   69,W
1A1F:  BSF    03.6
1A20:  MOVWF  6B
1A21:  BCF    03.6
1A22:  MOVF   68,W
1A23:  BSF    03.6
1A24:  MOVWF  6A
1A25:  BCF    03.6
1A26:  MOVF   67,W
1A27:  BSF    03.6
1A28:  MOVWF  69
1A29:  BCF    03.6
1A2A:  MOVF   66,W
1A2B:  BSF    03.6
1A2C:  MOVWF  68
1A2D:  BCF    0A.4
1A2E:  BCF    0A.3
1A2F:  BCF    03.6
1A30:  CALL   764
1A31:  BSF    0A.4
1A32:  BSF    0A.3
1A33:  BTFSS  03.0
1A34:  GOTO   338
....................          if(temp>(setpoint+setpointgap+4.5)){ 
1A35:  BCF    03.1
1A36:  MOVF   61,W
1A37:  BSF    03.5
1A38:  BSF    03.6
1A39:  MOVWF  1B
1A3A:  BCF    03.5
1A3B:  BCF    03.6
1A3C:  MOVF   60,W
1A3D:  BSF    03.5
1A3E:  BSF    03.6
1A3F:  MOVWF  1A
1A40:  BCF    03.5
1A41:  BCF    03.6
1A42:  MOVF   5F,W
1A43:  BSF    03.5
1A44:  BSF    03.6
1A45:  MOVWF  19
1A46:  BCF    03.5
1A47:  BCF    03.6
1A48:  MOVF   5E,W
1A49:  BSF    03.5
1A4A:  BSF    03.6
1A4B:  MOVWF  18
1A4C:  BCF    03.5
1A4D:  BCF    03.6
1A4E:  MOVF   65,W
1A4F:  BSF    03.5
1A50:  BSF    03.6
1A51:  MOVWF  1F
1A52:  BCF    03.5
1A53:  BCF    03.6
1A54:  MOVF   64,W
1A55:  BSF    03.5
1A56:  BSF    03.6
1A57:  MOVWF  1E
1A58:  BCF    03.5
1A59:  BCF    03.6
1A5A:  MOVF   63,W
1A5B:  BSF    03.5
1A5C:  BSF    03.6
1A5D:  MOVWF  1D
1A5E:  BCF    03.5
1A5F:  BCF    03.6
1A60:  MOVF   62,W
1A61:  BSF    03.5
1A62:  BSF    03.6
1A63:  MOVWF  1C
1A64:  BCF    0A.4
1A65:  BCF    03.5
1A66:  BCF    03.6
1A67:  CALL   000
1A68:  BSF    0A.4
1A69:  MOVF   77,W
1A6A:  BSF    03.6
1A6B:  MOVWF  60
1A6C:  MOVF   78,W
1A6D:  MOVWF  61
1A6E:  MOVF   79,W
1A6F:  MOVWF  62
1A70:  MOVF   7A,W
1A71:  MOVWF  63
1A72:  BCF    03.1
1A73:  MOVF   63,W
1A74:  BSF    03.5
1A75:  MOVWF  1B
1A76:  BCF    03.5
1A77:  MOVF   62,W
1A78:  BSF    03.5
1A79:  MOVWF  1A
1A7A:  BCF    03.5
1A7B:  MOVF   61,W
1A7C:  BSF    03.5
1A7D:  MOVWF  19
1A7E:  BCF    03.5
1A7F:  MOVF   60,W
1A80:  BSF    03.5
1A81:  MOVWF  18
1A82:  CLRF   1F
1A83:  CLRF   1E
1A84:  MOVLW  10
1A85:  MOVWF  1D
1A86:  MOVLW  81
1A87:  MOVWF  1C
1A88:  BCF    0A.4
1A89:  BCF    03.5
1A8A:  BCF    03.6
1A8B:  CALL   000
1A8C:  BSF    0A.4
1A8D:  MOVF   7A,W
1A8E:  BSF    03.6
1A8F:  MOVWF  67
1A90:  MOVF   79,W
1A91:  MOVWF  66
1A92:  MOVF   78,W
1A93:  MOVWF  65
1A94:  MOVF   77,W
1A95:  MOVWF  64
1A96:  BCF    03.6
1A97:  MOVF   69,W
1A98:  BSF    03.6
1A99:  MOVWF  6B
1A9A:  BCF    03.6
1A9B:  MOVF   68,W
1A9C:  BSF    03.6
1A9D:  MOVWF  6A
1A9E:  BCF    03.6
1A9F:  MOVF   67,W
1AA0:  BSF    03.6
1AA1:  MOVWF  69
1AA2:  BCF    03.6
1AA3:  MOVF   66,W
1AA4:  BSF    03.6
1AA5:  MOVWF  68
1AA6:  BCF    0A.4
1AA7:  BCF    0A.3
1AA8:  BCF    03.6
1AA9:  CALL   764
1AAA:  BSF    0A.4
1AAB:  BSF    0A.3
1AAC:  BTFSS  03.0
1AAD:  GOTO   332
....................             if(temp>(setpoint+setpointgap+tempalerta)){ 
1AAE:  BCF    03.1
1AAF:  MOVF   61,W
1AB0:  BSF    03.5
1AB1:  BSF    03.6
1AB2:  MOVWF  1B
1AB3:  BCF    03.5
1AB4:  BCF    03.6
1AB5:  MOVF   60,W
1AB6:  BSF    03.5
1AB7:  BSF    03.6
1AB8:  MOVWF  1A
1AB9:  BCF    03.5
1ABA:  BCF    03.6
1ABB:  MOVF   5F,W
1ABC:  BSF    03.5
1ABD:  BSF    03.6
1ABE:  MOVWF  19
1ABF:  BCF    03.5
1AC0:  BCF    03.6
1AC1:  MOVF   5E,W
1AC2:  BSF    03.5
1AC3:  BSF    03.6
1AC4:  MOVWF  18
1AC5:  BCF    03.5
1AC6:  BCF    03.6
1AC7:  MOVF   65,W
1AC8:  BSF    03.5
1AC9:  BSF    03.6
1ACA:  MOVWF  1F
1ACB:  BCF    03.5
1ACC:  BCF    03.6
1ACD:  MOVF   64,W
1ACE:  BSF    03.5
1ACF:  BSF    03.6
1AD0:  MOVWF  1E
1AD1:  BCF    03.5
1AD2:  BCF    03.6
1AD3:  MOVF   63,W
1AD4:  BSF    03.5
1AD5:  BSF    03.6
1AD6:  MOVWF  1D
1AD7:  BCF    03.5
1AD8:  BCF    03.6
1AD9:  MOVF   62,W
1ADA:  BSF    03.5
1ADB:  BSF    03.6
1ADC:  MOVWF  1C
1ADD:  BCF    0A.4
1ADE:  BCF    03.5
1ADF:  BCF    03.6
1AE0:  CALL   000
1AE1:  BSF    0A.4
1AE2:  MOVF   77,W
1AE3:  BSF    03.6
1AE4:  MOVWF  60
1AE5:  MOVF   78,W
1AE6:  MOVWF  61
1AE7:  MOVF   79,W
1AE8:  MOVWF  62
1AE9:  MOVF   7A,W
1AEA:  MOVWF  63
1AEB:  BCF    03.1
1AEC:  MOVF   63,W
1AED:  BSF    03.5
1AEE:  MOVWF  1B
1AEF:  BCF    03.5
1AF0:  MOVF   62,W
1AF1:  BSF    03.5
1AF2:  MOVWF  1A
1AF3:  BCF    03.5
1AF4:  MOVF   61,W
1AF5:  BSF    03.5
1AF6:  MOVWF  19
1AF7:  BCF    03.5
1AF8:  MOVF   60,W
1AF9:  BSF    03.5
1AFA:  MOVWF  18
1AFB:  MOVF   75,W
1AFC:  MOVWF  1F
1AFD:  MOVF   74,W
1AFE:  MOVWF  1E
1AFF:  MOVF   73,W
1B00:  MOVWF  1D
1B01:  MOVF   72,W
1B02:  MOVWF  1C
1B03:  BCF    0A.4
1B04:  BCF    03.5
1B05:  BCF    03.6
1B06:  CALL   000
1B07:  BSF    0A.4
1B08:  MOVF   7A,W
1B09:  BSF    03.6
1B0A:  MOVWF  67
1B0B:  MOVF   79,W
1B0C:  MOVWF  66
1B0D:  MOVF   78,W
1B0E:  MOVWF  65
1B0F:  MOVF   77,W
1B10:  MOVWF  64
1B11:  BCF    03.6
1B12:  MOVF   69,W
1B13:  BSF    03.6
1B14:  MOVWF  6B
1B15:  BCF    03.6
1B16:  MOVF   68,W
1B17:  BSF    03.6
1B18:  MOVWF  6A
1B19:  BCF    03.6
1B1A:  MOVF   67,W
1B1B:  BSF    03.6
1B1C:  MOVWF  69
1B1D:  BCF    03.6
1B1E:  MOVF   66,W
1B1F:  BSF    03.6
1B20:  MOVWF  68
1B21:  BCF    0A.4
1B22:  BCF    0A.3
1B23:  BCF    03.6
1B24:  CALL   764
1B25:  BSF    0A.4
1B26:  BSF    0A.3
1B27:  BTFSS  03.0
1B28:  GOTO   32C
....................                buzzerligado(); 
1B29:  BSF    07.1
1B2A:  BSF    06.5
....................             }else{ 
1B2B:  GOTO   32E
....................                buzzerdesligado(); 
1B2C:  BCF    07.1
1B2D:  BCF    06.5
....................             } 
....................             coolermaximo(); 
1B2E:  MOVLW  7B
1B2F:  MOVWF  15
1B30:  BSF    06.7
....................          }else{ 
1B31:  GOTO   335
....................             coolermedio();          
1B32:  MOVLW  50
1B33:  MOVWF  15
1B34:  BSF    06.7
....................          }       
....................          mergdesligado();     
1B35:  BCF    07.5
1B36:  BCF    06.6
....................        }else{ 
1B37:  GOTO   414
....................          if(temp<(setpoint-setpointgap)){ 
1B38:  BSF    03.1
1B39:  MOVF   61,W
1B3A:  BSF    03.5
1B3B:  BSF    03.6
1B3C:  MOVWF  1B
1B3D:  BCF    03.5
1B3E:  BCF    03.6
1B3F:  MOVF   60,W
1B40:  BSF    03.5
1B41:  BSF    03.6
1B42:  MOVWF  1A
1B43:  BCF    03.5
1B44:  BCF    03.6
1B45:  MOVF   5F,W
1B46:  BSF    03.5
1B47:  BSF    03.6
1B48:  MOVWF  19
1B49:  BCF    03.5
1B4A:  BCF    03.6
1B4B:  MOVF   5E,W
1B4C:  BSF    03.5
1B4D:  BSF    03.6
1B4E:  MOVWF  18
1B4F:  BCF    03.5
1B50:  BCF    03.6
1B51:  MOVF   65,W
1B52:  BSF    03.5
1B53:  BSF    03.6
1B54:  MOVWF  1F
1B55:  BCF    03.5
1B56:  BCF    03.6
1B57:  MOVF   64,W
1B58:  BSF    03.5
1B59:  BSF    03.6
1B5A:  MOVWF  1E
1B5B:  BCF    03.5
1B5C:  BCF    03.6
1B5D:  MOVF   63,W
1B5E:  BSF    03.5
1B5F:  BSF    03.6
1B60:  MOVWF  1D
1B61:  BCF    03.5
1B62:  BCF    03.6
1B63:  MOVF   62,W
1B64:  BSF    03.5
1B65:  BSF    03.6
1B66:  MOVWF  1C
1B67:  BCF    0A.4
1B68:  BCF    03.5
1B69:  BCF    03.6
1B6A:  CALL   000
1B6B:  BSF    0A.4
1B6C:  MOVF   69,W
1B6D:  BSF    03.6
1B6E:  MOVWF  67
1B6F:  BCF    03.6
1B70:  MOVF   68,W
1B71:  BSF    03.6
1B72:  MOVWF  66
1B73:  BCF    03.6
1B74:  MOVF   67,W
1B75:  BSF    03.6
1B76:  MOVWF  65
1B77:  BCF    03.6
1B78:  MOVF   66,W
1B79:  BSF    03.6
1B7A:  MOVWF  64
1B7B:  MOVF   7A,W
1B7C:  MOVWF  6B
1B7D:  MOVF   79,W
1B7E:  MOVWF  6A
1B7F:  MOVF   78,W
1B80:  MOVWF  69
1B81:  MOVF   77,W
1B82:  MOVWF  68
1B83:  BCF    0A.4
1B84:  BCF    0A.3
1B85:  BCF    03.6
1B86:  CALL   764
1B87:  BSF    0A.4
1B88:  BSF    0A.3
1B89:  BTFSS  03.0
1B8A:  GOTO   40E
....................             if(temp<(setpoint-setpointgap-tempalerta)){ 
1B8B:  BSF    03.1
1B8C:  MOVF   61,W
1B8D:  BSF    03.5
1B8E:  BSF    03.6
1B8F:  MOVWF  1B
1B90:  BCF    03.5
1B91:  BCF    03.6
1B92:  MOVF   60,W
1B93:  BSF    03.5
1B94:  BSF    03.6
1B95:  MOVWF  1A
1B96:  BCF    03.5
1B97:  BCF    03.6
1B98:  MOVF   5F,W
1B99:  BSF    03.5
1B9A:  BSF    03.6
1B9B:  MOVWF  19
1B9C:  BCF    03.5
1B9D:  BCF    03.6
1B9E:  MOVF   5E,W
1B9F:  BSF    03.5
1BA0:  BSF    03.6
1BA1:  MOVWF  18
1BA2:  BCF    03.5
1BA3:  BCF    03.6
1BA4:  MOVF   65,W
1BA5:  BSF    03.5
1BA6:  BSF    03.6
1BA7:  MOVWF  1F
1BA8:  BCF    03.5
1BA9:  BCF    03.6
1BAA:  MOVF   64,W
1BAB:  BSF    03.5
1BAC:  BSF    03.6
1BAD:  MOVWF  1E
1BAE:  BCF    03.5
1BAF:  BCF    03.6
1BB0:  MOVF   63,W
1BB1:  BSF    03.5
1BB2:  BSF    03.6
1BB3:  MOVWF  1D
1BB4:  BCF    03.5
1BB5:  BCF    03.6
1BB6:  MOVF   62,W
1BB7:  BSF    03.5
1BB8:  BSF    03.6
1BB9:  MOVWF  1C
1BBA:  BCF    0A.4
1BBB:  BCF    03.5
1BBC:  BCF    03.6
1BBD:  CALL   000
1BBE:  BSF    0A.4
1BBF:  MOVF   77,W
1BC0:  BSF    03.6
1BC1:  MOVWF  60
1BC2:  MOVF   78,W
1BC3:  MOVWF  61
1BC4:  MOVF   79,W
1BC5:  MOVWF  62
1BC6:  MOVF   7A,W
1BC7:  MOVWF  63
1BC8:  BSF    03.1
1BC9:  MOVF   63,W
1BCA:  BSF    03.5
1BCB:  MOVWF  1B
1BCC:  BCF    03.5
1BCD:  MOVF   62,W
1BCE:  BSF    03.5
1BCF:  MOVWF  1A
1BD0:  BCF    03.5
1BD1:  MOVF   61,W
1BD2:  BSF    03.5
1BD3:  MOVWF  19
1BD4:  BCF    03.5
1BD5:  MOVF   60,W
1BD6:  BSF    03.5
1BD7:  MOVWF  18
1BD8:  MOVF   75,W
1BD9:  MOVWF  1F
1BDA:  MOVF   74,W
1BDB:  MOVWF  1E
1BDC:  MOVF   73,W
1BDD:  MOVWF  1D
1BDE:  MOVF   72,W
1BDF:  MOVWF  1C
1BE0:  BCF    0A.4
1BE1:  BCF    03.5
1BE2:  BCF    03.6
1BE3:  CALL   000
1BE4:  BSF    0A.4
1BE5:  MOVF   69,W
1BE6:  BSF    03.6
1BE7:  MOVWF  67
1BE8:  BCF    03.6
1BE9:  MOVF   68,W
1BEA:  BSF    03.6
1BEB:  MOVWF  66
1BEC:  BCF    03.6
1BED:  MOVF   67,W
1BEE:  BSF    03.6
1BEF:  MOVWF  65
1BF0:  BCF    03.6
1BF1:  MOVF   66,W
1BF2:  BSF    03.6
1BF3:  MOVWF  64
1BF4:  MOVF   7A,W
1BF5:  MOVWF  6B
1BF6:  MOVF   79,W
1BF7:  MOVWF  6A
1BF8:  MOVF   78,W
1BF9:  MOVWF  69
1BFA:  MOVF   77,W
1BFB:  MOVWF  68
1BFC:  BCF    0A.4
1BFD:  BCF    0A.3
1BFE:  BCF    03.6
1BFF:  CALL   764
1C00:  BSF    0A.4
1C01:  BSF    0A.3
1C02:  BTFSS  03.0
1C03:  GOTO   407
....................                buzzerligado(); 
1C04:  BSF    07.1
1C05:  BSF    06.5
....................             }else{ 
1C06:  GOTO   409
....................                buzzerdesligado(); 
1C07:  BCF    07.1
1C08:  BCF    06.5
....................             } 
....................             mergligado(); 
1C09:  BSF    07.5
1C0A:  BSF    06.6
....................             coolerdesligado(); 
1C0B:  CLRF   15
1C0C:  BCF    06.7
....................          }else{ 
1C0D:  GOTO   414
....................             coolerdesligado(); 
1C0E:  CLRF   15
1C0F:  BCF    06.7
....................             mergdesligado(); 
1C10:  BCF    07.5
1C11:  BCF    06.6
....................             buzzerdesligado(); 
1C12:  BCF    07.1
1C13:  BCF    06.5
....................          } 
....................        } 
....................               
....................     
....................    }else{ // status de planta desligada 
1C14:  GOTO   41B
....................  
....................       buzzerdesligado(); 
1C15:  BCF    07.1
1C16:  BCF    06.5
....................       mergdesligado(); 
1C17:  BCF    07.5
1C18:  BCF    06.6
....................       coolerdesligado(); 
1C19:  CLRF   15
1C1A:  BCF    06.7
....................    } 
....................  
.................... } 
1C1B:  BSF    0A.3
1C1C:  BSF    0A.4
1C1D:  GOTO   5D5 (RETURN)
....................  
.................... #include "script_botoes.h"          // script de Botoes utilizados 
.................... void acionaBotoes(void){ 
....................        
....................    if(bt1==0){     
*
15C7:  BTFSC  06.0
15C8:  GOTO   5D5
....................    ligaplanta(naoalterasetpoint, local); 
15C9:  BSF    03.6
15CA:  CLRF   60
15CB:  MOVLW  01
15CC:  MOVWF  61
15CD:  BCF    0A.4
15CE:  BSF    0A.3
15CF:  BCF    03.6
15D0:  CALL   4F7
15D1:  BSF    0A.4
15D2:  BCF    0A.3
....................       while(bt1==0){ 
15D3:  BTFSS  06.0
....................       } 
15D4:  GOTO   5D3
....................    } 
....................     
....................    if(bt2==0){ 
15D5:  BTFSC  06.1
15D6:  GOTO   5E2
....................    desligaplanta(local); 
15D7:  MOVLW  01
15D8:  BSF    03.6
15D9:  MOVWF  60
15DA:  BCF    0A.4
15DB:  BSF    0A.3
15DC:  BCF    03.6
15DD:  CALL   609
15DE:  BSF    0A.4
15DF:  BCF    0A.3
....................       while(bt2==0){ 
15E0:  BTFSS  06.1
....................       } 
15E1:  GOTO   5E0
....................    } 
....................     
....................    if(bt3==0){ 
15E2:  BTFSC  06.2
15E3:  GOTO   66D
....................       checamodoop(); 
....................       //piscarele(); 
....................       while(bt3==0){ 
*
166B:  BTFSS  06.2
....................       } 
166C:  GOTO   66B
....................    } 
....................     
....................    if(bt4==0){ 
166D:  BTFSC  06.3
166E:  GOTO   6AC
....................    aumentasetpoint(); 
....................       while(bt4==0){ 
*
16AA:  BTFSS  06.3
....................       } 
16AB:  GOTO   6AA
....................    } 
....................     
....................    if(bt5==0){ 
16AC:  BTFSC  06.4
16AD:  GOTO   6EB
....................    diminuisetpoint(); 
....................       while(bt5==0){ 
*
16E9:  BTFSS  06.4
....................       } 
16EA:  GOTO   6E9
....................    } 
....................  
.................... /* 
....................    if(bt6==0){ 
....................    mostravalores(); 
....................       while(bt6==0){ 
....................       } 
....................    } 
.................... */ 
....................  
.................... } 
16EB:  BSF    0A.3
16EC:  BSF    0A.4
16ED:  GOTO   5D7 (RETURN)
....................  
....................  
.................... void main(){ 
*
1C1E:  CLRF   04
1C1F:  BCF    03.7
1C20:  MOVLW  1F
1C21:  ANDWF  03,F
1C22:  MOVLW  0C
1C23:  BSF    03.5
1C24:  MOVWF  19
1C25:  MOVLW  A2
1C26:  MOVWF  18
1C27:  MOVLW  90
1C28:  BCF    03.5
1C29:  MOVWF  18
1C2A:  BSF    03.5
1C2B:  BSF    1F.0
1C2C:  BSF    1F.1
1C2D:  BSF    1F.2
1C2E:  BCF    1F.3
1C2F:  MOVLW  07
1C30:  MOVWF  1C
....................    #include "script_startup.h" 
....................    set_tris_a(0b00111111); 
*
1D11:  MOVLW  3F
1D12:  BSF    03.5
1D13:  BCF    03.6
1D14:  MOVWF  05
....................    set_tris_b(0b00011111); 
1D15:  MOVLW  1F
1D16:  MOVWF  06
....................    set_tris_c(0b10000000); 
*
1D0F:  MOVLW  FF
1D10:  MOVWF  7E
*
1D17:  MOVLW  80
1D18:  MOVWF  07
1D19:  MOVWF  7E
....................    set_tris_d(0b00000000); 
1D1A:  MOVLW  00
1D1B:  MOVWF  08
....................    set_tris_e(0b00000000); 
1D1C:  BCF    09.0
1D1D:  BCF    09.1
1D1E:  BCF    09.2
....................    
....................    porta=0; 
1D1F:  BCF    03.5
1D20:  CLRF   05
....................    portb=0; 
1D21:  CLRF   06
....................    portc=0; 
1D22:  CLRF   07
....................    portd=0; 
1D23:  CLRF   08
....................    porte=0; 
1D24:  CLRF   09
....................     
....................    fim=26;                                        // caracter sinaliza fim da msg pronta para envio no modem. 
1D25:  MOVLW  1A
1D26:  MOVWF  35
....................    inicializa_lcd();                              // Inicializa LCD 
1D27:  BCF    0A.4
1D28:  BCF    0A.3
1D29:  GOTO   579
1D2A:  BSF    0A.4
1D2B:  BSF    0A.3
....................    limpa_lcd();                                   // Função Limpa conteúdo do LCD 
1D2C:  BCF    0A.4
1D2D:  BCF    0A.3
1D2E:  CALL   586
1D2F:  BSF    0A.4
1D30:  BSF    0A.3
....................    comando_lcd(0x80);                             // Escolhe linha 1 do LCD 
1D31:  MOVLW  80
1D32:  BSF    03.6
1D33:  MOVWF  62
1D34:  BCF    0A.4
1D35:  BCF    0A.3
1D36:  BCF    03.6
1D37:  CALL   56A
1D38:  BSF    0A.4
1D39:  BSF    0A.3
....................    printf(escreve_lcd,"TCC Fatec 2010");              // Escreve "TEXTO" no LCD 
1D3A:  BSF    03.6
1D3B:  CLRF   60
1D3C:  MOVF   60,W
1D3D:  BCF    0A.4
1D3E:  BCF    0A.3
1D3F:  BCF    03.6
1D40:  CALL   29E
1D41:  BSF    0A.4
1D42:  BSF    0A.3
1D43:  BSF    03.6
1D44:  INCF   60,F
1D45:  MOVWF  77
1D46:  BSF    03.5
1D47:  MOVWF  10
1D48:  BCF    0A.4
1D49:  BCF    0A.3
1D4A:  BCF    03.5
1D4B:  BCF    03.6
1D4C:  CALL   58C
1D4D:  BSF    0A.4
1D4E:  BSF    0A.3
1D4F:  MOVLW  0E
1D50:  BSF    03.6
1D51:  SUBWF  60,W
1D52:  BTFSS  03.2
1D53:  GOTO   53C
....................    comando_lcd(0xC0);                             // Escolhe linha 2 do LCD 
1D54:  MOVLW  C0
1D55:  MOVWF  62
1D56:  BCF    0A.4
1D57:  BCF    0A.3
1D58:  BCF    03.6
1D59:  CALL   56A
1D5A:  BSF    0A.4
1D5B:  BSF    0A.3
....................    printf(escreve_lcd,"Aut. Industrial");         // Escreve "TEXTO" no LCD    
1D5C:  BSF    03.6
1D5D:  CLRF   60
1D5E:  MOVF   60,W
1D5F:  BCF    0A.4
1D60:  BCF    0A.3
1D61:  BCF    03.6
1D62:  CALL   2B1
1D63:  BSF    0A.4
1D64:  BSF    0A.3
1D65:  BSF    03.6
1D66:  INCF   60,F
1D67:  MOVWF  77
1D68:  BSF    03.5
1D69:  MOVWF  10
1D6A:  BCF    0A.4
1D6B:  BCF    0A.3
1D6C:  BCF    03.5
1D6D:  BCF    03.6
1D6E:  CALL   58C
1D6F:  BSF    0A.4
1D70:  BSF    0A.3
1D71:  MOVLW  0F
1D72:  BSF    03.6
1D73:  SUBWF  60,W
1D74:  BTFSS  03.2
1D75:  GOTO   55E
....................    printf("ATE0\n\r");                             // Comando para desabilitar ECHO do modem GPRS 
1D76:  CLRF   60
1D77:  MOVF   60,W
1D78:  BCF    0A.4
1D79:  BCF    0A.3
1D7A:  BCF    03.6
1D7B:  CALL   2C5
1D7C:  BSF    0A.4
1D7D:  BSF    0A.3
1D7E:  BSF    03.6
1D7F:  INCF   60,F
1D80:  MOVWF  77
1D81:  BCF    03.6
1D82:  BTFSS  0C.4
1D83:  GOTO   582
1D84:  MOVWF  19
1D85:  MOVLW  06
1D86:  BSF    03.6
1D87:  SUBWF  60,W
1D88:  BTFSS  03.2
1D89:  GOTO   577
....................    printf("AT+CMGF=1\n\r");                        // Seta modem para repassar mensagens em caracteres na forma texto 
1D8A:  CLRF   60
1D8B:  MOVF   60,W
1D8C:  BCF    0A.4
1D8D:  BCF    0A.3
1D8E:  BCF    03.6
1D8F:  CALL   27D
1D90:  BSF    0A.4
1D91:  BSF    0A.3
1D92:  BSF    03.6
1D93:  INCF   60,F
1D94:  MOVWF  77
1D95:  BCF    03.6
1D96:  BTFSS  0C.4
1D97:  GOTO   596
1D98:  MOVWF  19
1D99:  MOVLW  0B
1D9A:  BSF    03.6
1D9B:  SUBWF  60,W
1D9C:  BTFSS  03.2
1D9D:  GOTO   58B
.................... //   printf("AT+CMGD=1\n\r");                        // Deleta qualquer mensagem guardada no modem para que nao haja erros na inicializacao 
....................     
....................    enable_interrupts(global);                    // habilita interrupções globais 
1D9E:  MOVLW  C0
1D9F:  BCF    03.6
1DA0:  IORWF  0B,F
....................    enable_interrupts(int_rda);                   // habilita interrupção rda 
1DA1:  BSF    03.5
1DA2:  BSF    0C.5
....................    enable_interrupts(int_timer1); 
1DA3:  BSF    0C.0
....................    limpa_msg();                                  // Função Limpa conteúdo do LCD 
1DA4:  BCF    0A.4
1DA5:  BCF    0A.3
1DA6:  BCF    03.5
1DA7:  GOTO   59D
1DA8:  BSF    0A.4
1DA9:  BSF    0A.3
....................    setup_adc_ports(AN0_AN1_AN2_AN3_AN4_AN5); 
1DAA:  BSF    03.5
1DAB:  BSF    1F.0
1DAC:  BCF    1F.1
1DAD:  BCF    1F.2
1DAE:  BSF    1F.3
....................    setup_adc(ADC_CLOCK_DIV_32);   
1DAF:  BCF    1F.6
1DB0:  BCF    03.5
1DB1:  BCF    1F.6
1DB2:  BSF    1F.7
1DB3:  BSF    03.5
1DB4:  BSF    1F.7
1DB5:  BCF    03.5
1DB6:  BSF    1F.0
....................    setup_timer_1 ( T1_INTERNAL | T1_DIV_BY_8 );   // timer para display de temperatura 
1DB7:  MOVLW  B5
1DB8:  MOVWF  10
....................    set_timer1(851);         
1DB9:  MOVLW  03
1DBA:  MOVWF  0F
1DBB:  MOVLW  53
1DBC:  MOVWF  0E
....................    setup_timer_2(T2_DIV_BY_16,124,1);             //frequencia de 1kHz 
1DBD:  MOVLW  00
1DBE:  MOVWF  78
1DBF:  IORLW  06
1DC0:  MOVWF  12
1DC1:  MOVLW  7C
1DC2:  BSF    03.5
1DC3:  MOVWF  12
....................    setup_ccp1(CCP_PWM);                           // CCP1 para PWM 
1DC4:  BCF    7E.2
1DC5:  MOVF   7E,W
1DC6:  MOVWF  07
1DC7:  BCF    03.5
1DC8:  BCF    07.2
1DC9:  MOVLW  0C
1DCA:  MOVWF  17
....................   
....................    coolerdesligado();                             // Seta o PWM em Zero para não deixar o Cooler ligado desde o início 
1DCB:  CLRF   15
1DCC:  BCF    06.7
....................    mergdesligado(); 
1DCD:  BCF    07.5
1DCE:  BCF    06.6
....................    buzzerdesligado(); 
1DCF:  BCF    07.1
1DD0:  BCF    06.5
....................    
....................  
....................  
....................        
....................    while(1){ 
....................       checaSMS(); 
1DD1:  BCF    0A.3
1DD2:  GOTO   000
1DD3:  BSF    0A.3
....................       checaTemperatura(); 
1DD4:  GOTO   000
....................       acionaBotoes(); 
1DD5:  BCF    0A.3
1DD6:  GOTO   5C7
1DD7:  BSF    0A.3
....................  
....................    } 
1DD8:  GOTO   5D1
.................... } 
1DD9:  SLEEP

Configuration Fuses:
   Word  1: 397A   HS NOWDT NOPUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD WRT_50%
